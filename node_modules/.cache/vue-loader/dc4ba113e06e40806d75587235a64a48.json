{"remainingRequest":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/src/components/Scatterplot_2.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/src/components/Scatterplot_2.vue","mtime":1705768152791},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/cache-loader/dist/cjs.js","mtime":1705744300535},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/thread-loader/dist/cjs.js","mtime":1705744300535},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/babel-loader/lib/index.js","mtime":1705744300565},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/cache-loader/dist/cjs.js","mtime":1705744300535},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/jabbarir79_A5/node_modules/vue-loader/lib/index.js","mtime":1705744299123}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgppbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ1NjYXR0ZXJwbG90XzEnLAogIHByb3BzOiB7CiAgfSwKICBkYXRhKCkgewogICAgY29uc3Qgc3ZnV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIDQgLyAxMjsKICAgIGNvbnN0IHN2Z0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuMzU7CiAgICByZXR1cm4gewogICAgICB6b29tZWRYU2NhbGU6IG51bGwsCiAgICAgIHpvb21lZFlTY2FsZTogbnVsbCwKICAgICAgc3ZnV2lkdGg6IHN2Z1dpZHRoLAogICAgICBzdmdIZWlnaHQ6IHN2Z0hlaWdodCwKICAgICAgc3ZnUGFkZGluZzogewogICAgICAgIHRvcDogNSwgcmlnaHQ6IDE1LCBib3R0b206IDYwLCBsZWZ0OiA2MCwKICAgICAgfSwKICAgICAgc2lnbmlmaWNhbnRDaGFuZ2U6IGZhbHNlLAogICAgfQogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuZHJhd0NoYXJ0KHRoaXMueFNjYWxlLCB0aGlzLnlTY2FsZSk7CiAgICB0aGlzLmFkZEJydXNoKCk7CiAgICB0aGlzLmluaXRpYWxpemUoKTsKICAgIC8vIHRoaXMucGFpbnRDaGFydCh0aGlzLnhTY2FsZSwgdGhpcy55U2NhbGUpOwoKICB9LAogIG1ldGhvZHM6IHsKICAgIGluaXRpYWxpemUoKSB7CiAgICAgIHZhciBsb2NhbGJydXNoZWRDb3VudHJpZXMgPSBbXTsKICAgICAgdGhpcy5maWx0ZXJlZERhdGEuZm9yRWFjaChkID0+IGxvY2FsYnJ1c2hlZENvdW50cmllcy5wdXNoKGQuaWQpKTsKICAgIH0sCiAgICByZXNldFpvb20oKSB7CiAgICAgIHRoaXMuem9vbWVkWFNjYWxlID0gbnVsbDsKICAgICAgdGhpcy56b29tZWRZU2NhbGUgPSBudWxsOwogICAgICAvLyB0aGlzLnBhaW50Q2hhcnQodGhpcy54U2NhbGUsIHRoaXMueVNjYWxlKTsKICAgICAgdGhpcy5kcmF3Q2hhcnQodGhpcy54U2NhbGUsIHRoaXMueVNjYWxlKTsKICAgICAgdGhpcy5pbml0aWFsaXplKCkKICAgIH0sCiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggdXBkYWdlCiAgICBkcmF3Q2hhcnQoeFNjYWxlLCB5U2NhbGUpIHsKICAgICAgeFNjYWxlID0geFNjYWxlIHx8IHRoaXMueFNjYWxlOwogICAgICB5U2NhbGUgPSB5U2NhbGUgfHwgdGhpcy55U2NhbGU7CgogICAgICAvLyBVcGRhdGUgYXhlcwogICAgICB0aGlzLmRyYXdYQXhpcyh4U2NhbGUpOwogICAgICB0aGlzLmRyYXdZQXhpcyh5U2NhbGUpOwogICAgICAKICAgICAgZDMuc2VsZWN0KHRoaXMuJHJlZnMuY2hhcnRHcm91cCkKICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMuc3ZnUGFkZGluZy5sZWZ0fSwke3RoaXMuc3ZnUGFkZGluZy50b3B9KWApOwogICAgICB0aGlzLmRyYXdQb2ludHMoeFNjYWxlLCB5U2NhbGUpOwogICAgICAvLyB0aGlzLnBhaW50Q2hhcnQoeFNjYWxlLCB5U2NhbGUpOwogICAgfSwKICAgIC8vIGJydXNoIGZvciBzaG93aW5nIG9uIGNob3JvcGxldGhtYXAKICAgIGFkZEJydXNoKCkgewogICAgICB0aGlzLmJydXNoID0gZDMuYnJ1c2goKQogICAgICAgIC5leHRlbnQoW1swLDBdLCBbdGhpcy5zdmdXaWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0LCAKICAgICAgICAgIHRoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLmJvdHRvbSAtIHRoaXMuc3ZnUGFkZGluZy50b3BdXSkKICAgICAgICAub24oJ2VuZCcsIHRoaXMub25CcnVzaCk7CiAgICAgIAogICAgICBkMy5zZWxlY3QodGhpcy4kcmVmcy5icnVzaEdyb3VwKQogICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpCiAgICAgICAgLmNhbGwodGhpcy5icnVzaCk7CiAgICB9LAogICAgLy8gZ2V0IHN0YXRlcyBpbiBicnVzaAogICAgb25CcnVzaChldmVudCkgewogICAgICB0aGlzLnNpZ25pZmljYW50Q2hhbmdlID0gdHJ1ZTsKICAgICAgdmFyIHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbjsKICAgICAgdmFyIGxvY2FsYnJ1c2hlZENvdW50cmllcyA9IFtdOwogICAgICB2YXIgeDAseDEseTAseTEsaWRsZVRpbWVvdXQ7CiAgICAgIGlmICghc2VsZWN0aW9uKSB7CiAgICAgICAgLy8gUmVzZXQgem9vbSBhbmQgY2xlYXIgYnJ1c2hlZCBjb3VudHJpZXMKICAgICAgICB0aGlzLmZpbHRlcmVkRGF0YS5mb3JFYWNoKGQgPT4gbG9jYWxicnVzaGVkQ291bnRyaWVzLnB1c2goZC5pZCkpOwogICAgICAgIGlmICghaWRsZVRpbWVvdXQpIHJldHVybiBpZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgaWRsZVRpbWVvdXQgPSBudWxsCiAgICAgICAgfSwgMSkgICAgCiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzY2FsZXMgZm9yIHpvb20KICAgICAgICBpZiAodGhpcy56b29tZWRYU2NhbGUpIHsKICAgICAgICAgIHgwID0gdGhpcy56b29tZWRYU2NhbGUuaW52ZXJ0KHNlbGVjdGlvblswXVswXSk7CiAgICAgICAgICB4MSA9IHRoaXMuem9vbWVkWFNjYWxlLmludmVydChzZWxlY3Rpb25bMV1bMF0pOwogICAgICAgICAgeTAgPSB0aGlzLnpvb21lZFlTY2FsZS5pbnZlcnQoc2VsZWN0aW9uWzFdWzFdKTsKICAgICAgICAgIHkxID0gdGhpcy56b29tZWRZU2NhbGUuaW52ZXJ0KHNlbGVjdGlvblswXVsxXSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHgwID0gdGhpcy54U2NhbGUuaW52ZXJ0KHNlbGVjdGlvblswXVswXSk7CiAgICAgICAgICB4MSA9IHRoaXMueFNjYWxlLmludmVydChzZWxlY3Rpb25bMV1bMF0pOwogICAgICAgICAgeTAgPSB0aGlzLnlTY2FsZS5pbnZlcnQoc2VsZWN0aW9uWzFdWzFdKTsKICAgICAgICAgIHkxID0gdGhpcy55U2NhbGUuaW52ZXJ0KHNlbGVjdGlvblswXVsxXSk7CiAgICAgICAgfQoKICAgICAgICB0aGlzLnpvb21lZFhTY2FsZSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKFt4MCwgeDFdKS5yYW5nZShbMCwgdGhpcy5zdmdXaWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0XSk7CiAgICAgICAgdGhpcy56b29tZWRZU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbeTAsIHkxXSkucmFuZ2UoW3RoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20sIDBdKTsKCiAgICAgICAgdGhpcy5kcmF3Q2hhcnQodGhpcy56b29tZWRYU2NhbGUsIHRoaXMuem9vbWVkWVNjYWxlKTsKCiAgICAgICAgdGhpcy5maWx0ZXJlZERhdGEuZm9yRWFjaChkID0+IHsKICAgICAgICAgIGlmIChkLmVuZXJneUdlbmVyYXRpb24gPj0geTAgJiYgZC5lbmVyZ3lHZW5lcmF0aW9uIDw9IHkxICYmIGQuZW5lcmd5Q2FwYWNpdHkgPj0geDAgJiYgZC5lbmVyZ3lDYXBhY2l0eSA8PSB4MSkgewogICAgICAgICAgICBsb2NhbGJydXNoZWRDb3VudHJpZXMucHVzaChkLmlkKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICAKICAgICAgfQoKICAgICAgLy8gdGhpcy5wYWludENoYXJ0KHRoaXMuem9vbWVkWFNjYWxlLCB0aGlzLnpvb21lZFlTY2FsZSk7CgogICAgICBkMy5zZWxlY3QoJyNzY2F0dGVyMi1zdmcnKS5zZWxlY3QoIi5icnVzaCIpLmNhbGwodGhpcy5icnVzaC5tb3ZlLCBudWxsKTsKICAgIH0sCiAgICBkcmF3WEF4aXMoeFNjYWxlKSB7CiAgICAgIGNvbnN0IHhBeGlzR3JvdXAgPSBkMy5zZWxlY3QodGhpcy4kcmVmcy5heGlzWCkKICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke3RoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b219KWApCiAgICAgICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh4U2NhbGUpKTsKCiAgICAgIC8vIFJvdGF0ZSB0aGUgdGlja3MKICAgICAgeEF4aXNHcm91cC5zZWxlY3RBbGwoIi50aWNrIHRleHQiKQogICAgICAuYXR0cigidHJhbnNmb3JtIiwgInJvdGF0ZSg1MCkiKQogICAgICAuYXR0cigieCIsIDkpCiAgICAgIC5hdHRyKCJ5IiwgMCkKICAgICAgLnN0eWxlKCJ0ZXh0LWFuY2hvciIsICJzdGFydCIpOwoKICAgICAgLy8gUG9zaXRpb24gdGhlIGF4aXMgbGFiZWwKICAgICAgeEF4aXNHcm91cC5hcHBlbmQoJ3RleHQnKQogICAgICAuYXR0cignY2xhc3MnLCAneC1heGlzLWxhYmVsJykKICAgICAgLmF0dHIoJ3gnLCB0aGlzLnN2Z1dpZHRoIC8gMikKICAgICAgLmF0dHIoJ3knLCB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tIC0gNSkKCiAgICAgIAogICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpCiAgICAgIC5zdHlsZSgnZmlsbCcsICdibGFjaycpCiAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEycHgnKQogICAgICAudGV4dCgnUmVuZXdhYmxlIEVuZXJneSBDYXBhY2l0eScpOwogICAgfSwKICAgIGRyYXdZQXhpcyh5U2NhbGUpIHsKICAgICAgY29uc3QgeUF4aXNHcm91cCA9IGQzLnNlbGVjdCh0aGlzLiRyZWZzLmF4aXNZKQogICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsIDApYCkKICAgICAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKQogICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEwcHgnKTsKCiAgICAgIC8vIFJvdGF0ZSB0aGUgdGlja3MKICAgICAgeUF4aXNHcm91cC5zZWxlY3RBbGwoJy50aWNrIHRleHQnKQogICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKC01MCknKQogICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJyk7CgogICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHktYXhpcyBsYWJlbCBiZWZvcmUgYWRkaW5nIGEgbmV3IG9uZQogICAgICB5QXhpc0dyb3VwLnNlbGVjdEFsbCgnLnktYXhpcy1sYWJlbCcpLnJlbW92ZSgpOwoKICAgICAgLy8gQWRkIG5ldyB5LWF4aXMgbGFiZWwKICAgICAgeUF4aXNHcm91cC5hcHBlbmQoJ3RleHQnKQogICAgICAgIC5hdHRyKCdjbGFzcycsICd5LWF4aXMtbGFiZWwnKQogICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKC05MCknKQogICAgICAgIC5hdHRyKCd5JywgLXRoaXMuc3ZnUGFkZGluZy5sZWZ0ICsgMTUpCiAgICAgICAgLmF0dHIoJ3gnLCAtdGhpcy5zdmdIZWlnaHQgLyAyKSAvLyBQb3NpdGlvbiBpbiB0aGUgbWlkZGxlIG9mIHktYXhpcwogICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJykgLy8gQ2VudGVyIHRoZSB0ZXh0IG9uIGl0cyB4IHBvc2l0aW9uCiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ2JsYWNrJykKICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMnB4JykKICAgICAgICAudGV4dCgnTm9uLVJlbmV3YWJsZSBFbmVyZ3kgQ2FwYWNpdHknKTsKICAgIH0sCgoKICAgIC8vIGFkZCBjb3VudHJ5IHBvaW50cyBvbiBzY2F0dGVycGxvdAogICAgZHJhd1BvaW50cyh4U2NhbGUsIHlTY2FsZSkgewogICAgICBjb25zdCBwb2ludHNHcm91cCA9IGQzLnNlbGVjdCh0aGlzLiRyZWZzLnBvaW50c0dyb3VwKTsKICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdCgiI3Rvb2x0aXAiKTsKICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMuc2lnbmlmaWNhbnRDaGFuZ2U/IGQzLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApIDogZDMudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApOwoKICAgICAgY29uc3QgeFJhbmdlID0geFNjYWxlLnJhbmdlKCk7CiAgICAgIGNvbnN0IHlSYW5nZSA9IHlTY2FsZS5yYW5nZSgpOwogICAgICBjb25zdCBpbkJvdW5kRGF0YSA9IHRoaXMuZmlsdGVyZWREYXRhLmZpbHRlcihkID0+IHsKCiAgICAgICAgY29uc3QgY3ggPSB4U2NhbGUoZC5yZW5ld2FibGUpOwogICAgICAgIGNvbnN0IGN5ID0geVNjYWxlKGQubm9uUmVuZXdhYmxlKTsKICAgICAgICAKCgogICAgICAgIHJldHVybiBjeCA+PSB4UmFuZ2VbMF0gJiYgY3ggPD0geFJhbmdlWzFdICYmIGN5IDw9IHlSYW5nZVswXSAmJiBjeSA+PSB5UmFuZ2VbMV07CiAgICAgIH0pOwogICAgICBwb2ludHNHcm91cC5zZWxlY3RBbGwoJy5wb2ludCcpCiAgICAgICAgLmRhdGEoaW5Cb3VuZERhdGEsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaWQ7IH0pCiAgICAgICAgLmpvaW4oCiAgICAgICAgICBlbnRlciA9PiBlbnRlci5hcHBlbmQoJ2NpcmNsZScpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludCcpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKGQucmVuZXdhYmxlKSkKICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgdGhpcy5zdmdIZWlnaHQgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tKSAvLyBzdGFydCBmcm9tIGJvdHRvbQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIDYpIC8vIHN0YXJ0IGZyb20gemVybyByYWRpdXMKICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoZW50ZXIgPT4gZW50ZXIudHJhbnNpdGlvbih0cmFuc2l0aW9uKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC5ub25SZW5ld2FibGUpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA2KSksCiAgICAgICAgICB1cGRhdGUgPT4gdXBkYXRlLmNhbGwodXBkYXRlID0+IHVwZGF0ZS50cmFuc2l0aW9uKHRyYW5zaXRpb24pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4geFNjYWxlKGQucmVuZXdhYmxlKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC5ub25SZW5ld2FibGUpKSksCiAgICAgICAgICBleGl0ID0+IGV4aXQuY2FsbChleGl0ID0+IGV4aXQudHJhbnNpdGlvbih0cmFuc2l0aW9uKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgdGhpcy5zdmdIZWlnaHQgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpKQogICAgICAgICkKICAgICAgICAuYXR0cignZmlsbCcsICJyZ2IoMSwgMzksIDM5KSIpCiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldmVudCwgZCkgewogICAgICAgICAgZDMuc2VsZWN0KHRoaXMpCiAgICAgICAgICAgIC5yYWlzZSgpCiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnZ3JlZW4nKQogICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7CiAgICAgICAgICBsZXQgcmVuZXdhYmxlRW5lcmd5VGVtcCA9IGQucmVuZXdhYmxlID09PSAwID8gJ05vIERhdGEnIDogZC5yZW5ld2FibGUudG9GaXhlZCgyKTsKICAgICAgICAgIGxldCBub25SZW5ld2FibGVFbmVyZ3lUZW1wID0gZC5ub25SZW5ld2FibGUgPT09IDAgPyAnTm8gRGF0YScgOiBkLm5vblJlbmV3YWJsZS50b0ZpeGVkKDIpOwogICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKCkKICAgICAgICAgICAgLmR1cmF0aW9uKDIwMCkKICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7CiAgICAgICAgICB0b29sdGlwLmh0bWwoYAogICAgICAgICAgICA8dGFibGU+CiAgICAgICAgICAgICAgPHRyPjx0ZCBjbGFzcz0ibGFiZWwiPkNvdW50cnk6PC90ZD4gICAgICAgICA8dGQgY2xhc3M9ImNvdW50cnlfdmFsdWUiPiR7ZC5jb3VudHJ5fTwvdGQ+PC90cj4KICAgICAgICAgICAgICA8dHI+PHRkIGNsYXNzPSJsYWJlbCI+Tm9uLVJlbmV3YWJsZSBFbmVyZ3k6PC90ZD4gICAgIDx0ZCBjbGFzcz0idmFsdWUiPiR7bm9uUmVuZXdhYmxlRW5lcmd5VGVtcH08L3RkPjwvdHI+CiAgICAgICAgICAgICAgPHRyPjx0ZCBjbGFzcz0ibGFiZWwiPlJlbmV3YWJsZSBFbmVyZ3k6PC90ZD4gICAgICAgIDx0ZCBjbGFzcz0idmFsdWUiPiR7cmVuZXdhYmxlRW5lcmd5VGVtcH08L3RkPjwvdHI+CiAgICAgICAgICAgIDwvdGFibGU+CiAgICAgICAgICBgKQogICAgICAgICAgLnN0eWxlKCdsZWZ0JywgKGV2ZW50LmNsaWVudFggLSAyNzUpICsgJ3B4JykKICAgICAgICAgIC5zdHlsZSgndG9wJywgKGV2ZW50LmNsaWVudFkgLSAxMDApICsgJ3B4Jyk7CiAgICAgICAgfSkKICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7CiAgICAgICAgICBkMy5zZWxlY3QodGhpcykKICAgICAgICAgICAgLmF0dHIoJ3InLCA2KQogICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ25vbmUnKQogICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7CiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKQogICAgICAgICAgICAuZHVyYXRpb24oNTAwKQogICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTsKICAgICAgICB9KQogICAgICAgIAogICAgICB0aGlzLnNpZ25pZmljYW50Q2hhbmdlID0gZmFsc2U7CiAgICB9LAogICAgICAKICAgIC8vIGNvbG9yaW5nIHRoZSBncmlkCiAgICAvLyBwYWludENoYXJ0KHhTY2FsZSwgeVNjYWxlKSB7CiAgICAvLyAgIHhTY2FsZSA9IHhTY2FsZSB8fCB0aGlzLnhTY2FsZTsKICAgIC8vICAgeVNjYWxlID0geVNjYWxlIHx8IHRoaXMueVNjYWxlOwogICAgLy8gICBjb25zdCBiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KHRoaXMuJHJlZnMuZ3JpZEJhY2tncm91bmQpOwogICAgLy8gICBiYWNrZ3JvdW5kLnNlbGVjdEFsbCgncmVjdCcpLnJlbW92ZSgpCiAgICAvLyAgIGJhY2tncm91bmQuc2VsZWN0QWxsKCcjcGxvdC1hcmVhLWNsaXAtYmFja2dyb3VuZCcpLnJlbW92ZSgpCiAgICAvLyAgIGNvbnN0IGNvbG9ycyA9IFsKICAgIC8vICAgICAicmdiKDIzMCwgMjMwLCAyMzApIiwKICAgIC8vICAgICAicmdiKDIyMCwgMjIwLCAyMjApIiwKICAgIC8vICAgICAicmdiKDIzMCwgMjMwLCAyMzApIiwKICAgIC8vICAgICAicmdiKDIyMCwgMjIwLCAyMjApIiwgCiAgICAvLyAgICAgInJnYigyMzAsIDIzMCwgMjMwKSIsIAogICAgLy8gICAgICJyZ2IoMjIwLCAyMjAsIDIyMCkiLAogICAgLy8gICAgICJyZ2IoMjMwLCAyMzAsIDIzMCkiLCAKICAgIC8vICAgICAicmdiKDIyMCwgMjIwLCAyMjApIiwKICAgIC8vICAgICAicmdiKDIzMCwgMjMwLCAyMzApIiwKICAgIC8vICAgXTsKICAgIC8vICAgYmFja2dyb3VuZC5hcHBlbmQoImRlZnMiKS5hcHBlbmQoImNsaXBQYXRoIikKICAgIC8vICAgICAuYXR0cigiaWQiLCAicGxvdC1hcmVhLWNsaXAtYmFja2dyb3VuZCIpCiAgICAvLyAgICAgLmFwcGVuZCgicmVjdCIpCiAgICAvLyAgICAgLmF0dHIoIndpZHRoIiwgdGhpcy5zdmdXaWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0KQogICAgLy8gICAgIC5hdHRyKCJoZWlnaHQiLCB0aGlzLnN2Z0hlaWdodCAtIHRoaXMuc3ZnUGFkZGluZy50b3AgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tKTsKICAgIC8vICAgY29uc3QgeEZpcnN0VGljayA9IHRoaXMucmVuZXdhYmxlRW5lcmd5TWluICsgKHRoaXMucmVuZXdhYmxlRW5lcmd5TWF4IC0gdGhpcy5yZW5ld2FibGVFbmVyZ3lNaW4pLzM7CiAgICAvLyAgIGNvbnN0IHhTZWNvbmRUaWNrID0gdGhpcy5yZW5ld2FibGVFbmVyZ3lNaW4gKyAyKih0aGlzLnJlbmV3YWJsZUVuZXJneU1heCAtIHRoaXMucmVuZXdhYmxlRW5lcmd5TWluKS8zOwogICAgLy8gICBjb25zdCB4VmFsdWVzID0gW3RoaXMucmVuZXdhYmxlRW5lcmd5TWluLCB4Rmlyc3RUaWNrLCB4U2Vjb25kVGljaywgdGhpcy5yZW5ld2FibGVFbmVyZ3lNYXhdOwogICAgLy8gICBjb25zdCB5Rmlyc3RUaWNrID0gdGhpcy5ub25SZW5ld2FibGVFbmVyZ3lNaW4gKyAodGhpcy5ub25SZW5ld2FibGVFbmVyZ3lNYXggLSB0aGlzLm5vblJlbmV3YWJsZUVuZXJneU1pbikvMzsKICAgIC8vICAgY29uc3QgeVNlY29uZFRpY2sgPSB0aGlzLm5vblJlbmV3YWJsZUVuZXJneU1pbiArIDIqKHRoaXMubm9uUmVuZXdhYmxlRW5lcmd5TWF4IC0gdGhpcy5ub25SZW5ld2FibGVFbmVyZ3lNaW4pLzM7CiAgICAvLyAgIGNvbnN0IHlWYWx1ZXMgPSBbdGhpcy5ub25SZW5ld2FibGVFbmVyZ3lNaW4sIHlGaXJzdFRpY2ssIHlTZWNvbmRUaWNrLHRoaXMubm9uUmVuZXdhYmxlRW5lcmd5TWF4XTsKICAgIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCB5VmFsdWVzLmxlbmd0aCAtIDE7IGkrKykgewogICAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgeFZhbHVlcy5sZW5ndGggLSAxOyBqKyspIHsKICAgIC8vICAgICAgIGJhY2tncm91bmQuYXBwZW5kKCdyZWN0JykKICAgIC8vICAgICAgICAgLmF0dHIoJ3gnLCB4U2NhbGUoeFZhbHVlc1tqXSkpCiAgICAvLyAgICAgICAgIC5hdHRyKCd5JywgeVNjYWxlKHlWYWx1ZXNbaSsxXSkpCiAgICAvLyAgICAgICAgIC5hdHRyKCJjbGlwLXBhdGgiLCAidXJsKCNwbG90LWFyZWEtY2xpcC1iYWNrZ3JvdW5kKSIpCiAgICAvLyAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3JzW2ogKyBpICogM10pCiAgICAvLyAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMCkgLy8gU3RhcnQgd2l0aCBhbiBvcGFjaXR5IG9mIDAgZm9yIHRoZSB0cmFuc2l0aW9uCiAgICAvLyAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHhTY2FsZSh4VmFsdWVzW2orMV0pIC0geFNjYWxlKHhWYWx1ZXNbal0pKQogICAgLy8gICAgICAgICAuYXR0cignaGVpZ2h0JywgeVNjYWxlKHlWYWx1ZXNbaV0pIC0geVNjYWxlKHlWYWx1ZXNbaSsxXSkpCiAgICAvLyAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSk7CiAgICAvLyAgICAgfQogICAgLy8gICB9CiAgICAvLyB9LAogICAgc3VtRW5lcmd5Q2FwYWNpdHlCeUNvdW50cnkoZGF0YSkgewogICAgICAvLyBBc3N1bWluZyBlYWNoIGVudHJ5IGluIGBkYXRhYCBoYXMgYSBgY291bnRyeWAgZmllbGQgYW5kIGEgYGNhcGFjaXR5YCBmaWVsZAogICAgICBjb25zdCBzdW1tZWREYXRhID0gZGF0YS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gewogICAgICAgIGNvbnN0IGNvdW50cnkgPSBpdGVtLmNvdW50cnk7CiAgICAgICAgaWYgKCFhY2NbY291bnRyeV0pIHsKICAgICAgICAgIGFjY1tjb3VudHJ5XSA9IHsgLi4uaXRlbSwgY2FwYWNpdHk6IDAgfTsgLy8gY29weSBhbGwgcHJvcGVydGllcwogICAgICAgIH0KICAgICAgICBhY2NbY291bnRyeV0uY2FwYWNpdHkgKz0gcGFyc2VGbG9hdChpdGVtLmNhcGFjaXR5KSB8fCAwOwogICAgICAgIHJldHVybiBhY2M7CiAgICAgIH0sIHt9KTsKCiAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBiYWNrIGludG8gYW4gYXJyYXkKICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3VtbWVkRGF0YSk7CiAgICB9LAogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGZpbHRlcmVkRGF0YSgpIHsKICAgICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLmZpbHRlcihkID0+IGQuZW5lcmd5Q2FwYWNpdHkgIT09IDAgJiYgZC5lbmVyZ3lDYXBhY2l0eSAhPT0gMCk7CiAgICB9LAogICAgY29tYmluZWREYXRhKCkgewogICAgICBsZXQgdG90YWxSZW5ld2FibGUgPSB0aGlzLmVuZXJneUNhcGFjaXR5CiAgICAgICAgLmZpbHRlcihlYyA9PiBlY1snZW5lcmd5VHlwZSddID09PSAnVG90YWwgUmVuZXdhYmxlJykKICAgICAgICAuZmlsdGVyKGVjID0+IGVjLmlkKQogICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50KSA9PiB7CiAgICAgICAgICBjb25zdCB2YWx1ZVRvQWRkID0gTnVtYmVyKGN1cnJlbnQudmFsdWUpIHx8IDA7CiAgICAgICAgICBpZiAoYWNjdW11bGF0b3JbY3VycmVudC5pZF0pIHsKICAgICAgICAgICAgYWNjdW11bGF0b3JbY3VycmVudC5pZF0udmFsdWUgKz0gdmFsdWVUb0FkZDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGFjY3VtdWxhdG9yW2N1cnJlbnQuaWRdID0gewogICAgICAgICAgICAgIGlkOiBjdXJyZW50LmlkLAogICAgICAgICAgICAgIGNvdW50cnk6IGN1cnJlbnQuY291bnRyeSwKICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUb0FkZAogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yOwogICAgICAgICAgfSwge30pOwogICAgICBsZXQgdG90YWxOb25SZW5ld2FibGUgPSB0aGlzLmVuZXJneUNhcGFjaXR5CiAgICAgICAgLmZpbHRlcihlYyA9PiBlY1snZW5lcmd5VHlwZSddID09PSAnVG90YWwgTm9uLVJlbmV3YWJsZScpCiAgICAgICAgLmZpbHRlcihlYyA9PiBlYy5pZCkKICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4gewogICAgICAgICAgY29uc3QgdmFsdWVUb0FkZCA9IE51bWJlcihjdXJyZW50LnZhbHVlKSB8fCAwOwogICAgICAgICAgaWYgKGFjY3VtdWxhdG9yW2N1cnJlbnQuaWRdKSB7CiAgICAgICAgICAgIGFjY3VtdWxhdG9yW2N1cnJlbnQuaWRdLnZhbHVlICs9IHZhbHVlVG9BZGQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBhY2N1bXVsYXRvcltjdXJyZW50LmlkXSA9IHsKICAgICAgICAgICAgICBpZDogY3VycmVudC5pZCwKICAgICAgICAgICAgICBjb3VudHJ5OiBjdXJyZW50LmNvdW50cnksCiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVG9BZGQKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjsKICAgICAgICAgIH0sIHt9KTsKICAgICAgCiAgICAgIGxldCByZW5ld2FibGVBcnJheSA9IE9iamVjdC52YWx1ZXModG90YWxSZW5ld2FibGUpOwogICAgICBsZXQgbm9uUmVuZXdhYmxlQXJyYXkgPSBPYmplY3QudmFsdWVzKHRvdGFsTm9uUmVuZXdhYmxlKTsKICAgICAgbGV0IGNvbWJpbmVkID0gcmVuZXdhYmxlQXJyYXkubWFwKHJuID0+IHsKICAgICAgICBsZXQgdG90YWxOb25SZW5ld2FibGVEYXRhID0gbm9uUmVuZXdhYmxlQXJyYXkuZmluZChuciA9PiBuci5pZCA9PT0gcm4uaWQpOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBpZDogcm4uaWQsCiAgICAgICAgICBjb3VudHJ5OiBybi5jb3VudHJ5LAogICAgICAgICAgcmVuZXdhYmxlOiBybi52YWx1ZSwKICAgICAgICAgIG5vblJlbmV3YWJsZTogdG90YWxOb25SZW5ld2FibGVEYXRhPyB0b3RhbE5vblJlbmV3YWJsZURhdGEudmFsdWU6IDAsCiAgICAgICAgfTsKICAgICAgfSk7CiAgICAgIHJldHVybiBjb21iaW5lZDsKICAgIH0sCiAgICBlbmVyZ3lDYXBhY2l0eTogewogICAgICBnZXQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuZW5lcmd5Q2FwYWNpdHk7CiAgICAgIH0KICAgIH0sCiAgICBlbmVyZ3lHZW5lcmF0aW9uOiB7CiAgICAgIGdldCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5lbmVyZ3lHZW5lcmF0aW9uOwogICAgICB9CiAgICB9LAogICAgbm9uUmVuZXdhYmxlRW5lcmd5TWF4KCkgewogICAgICBjb25zdCBtYXhOb25SZW5ld2FibGUgPSBNYXRoLm1heCguLi50aGlzLmZpbHRlcmVkRGF0YS5tYXAoZCA9PiBkLm5vblJlbmV3YWJsZSkpOwogICAgICBsZXQgcm91bmRlZE1heDsKICAgICAgaWYgKG1heE5vblJlbmV3YWJsZSA+IDEwMDAwMDApIHsKICAgICAgICByb3VuZGVkTWF4ID0gTWF0aC5jZWlsKG1heE5vblJlbmV3YWJsZSAvIDEwMDAwMCkgKiAxMDAwMDA7CiAgICAgIH0gZWxzZSBpZiAobWF4Tm9uUmVuZXdhYmxlID4gMTAwMDAwKSB7CiAgICAgICAgcm91bmRlZE1heCA9IE1hdGguY2VpbChtYXhOb25SZW5ld2FibGUgLyAxMDAwMCkgKiAxMDAwMDsKICAgICAgfSBlbHNlIGlmIChtYXhOb25SZW5ld2FibGUgPiAxMDAwMCkgewogICAgICAgIHJvdW5kZWRNYXggPSBNYXRoLmNlaWwobWF4Tm9uUmVuZXdhYmxlIC8gMTAwMCkgKiAxMDAwOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vIHJvdW5kaW5nIG5lZWRlZAogICAgICAgIHJvdW5kZWRNYXggPSBtYXhOb25SZW5ld2FibGU7CiAgICAgIH0KICAgICAgcmV0dXJuIHJvdW5kZWRNYXg7CiAgICAgIC8vIHJldHVybiAxMzAwMDAwOwogICAgfSwKICAgIG5vblJlbmV3YWJsZUVuZXJneU1pbigpIHsKICAgICAgY29uc3QgbWluTm9uUmVuZXdhYmxlID0gTWF0aC5taW4oLi4udGhpcy5maWx0ZXJlZERhdGEubWFwKGQgPT4gZC5ub25SZW5ld2FibGUpKTsKICAgICAgcmV0dXJuIG1pbk5vblJlbmV3YWJsZTsKICAgIH0sCiAgICByZW5ld2FibGVFbmVyZ3lNYXgoKSB7CiAgICAgIGNvbnN0IG1heFJlbmV3YWJsZSA9IE1hdGgubWF4KC4uLnRoaXMuZmlsdGVyZWREYXRhLm1hcChkID0+IGQucmVuZXdhYmxlKSk7CiAgICAgIGxldCByb3VuZGVkTWF4OwogICAgICBpZiAobWF4UmVuZXdhYmxlID4gMTAwMDAwMCkgewogICAgICAgIHJvdW5kZWRNYXggPSBNYXRoLmNlaWwobWF4UmVuZXdhYmxlIC8gMTAwMDAwKSAqIDEwMDAwMDsKICAgICAgfSBlbHNlIGlmIChtYXhSZW5ld2FibGUgPiAxMDAwMDApIHsKICAgICAgICByb3VuZGVkTWF4ID0gTWF0aC5jZWlsKG1heFJlbmV3YWJsZSAvIDEwMDAwKSAqIDEwMDAwOwogICAgICB9IGVsc2UgaWYgKG1heFJlbmV3YWJsZSA+IDEwMDAwKSB7CiAgICAgICAgcm91bmRlZE1heCA9IE1hdGguY2VpbChtYXhSZW5ld2FibGUgLyAxMDAwKSAqIDEwMDA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gTm8gcm91bmRpbmcgbmVlZGVkCiAgICAgICAgcm91bmRlZE1heCA9IG1heFJlbmV3YWJsZTsKICAgICAgfQogICAgICByZXR1cm4gcm91bmRlZE1heDsKICAgICAgLy8gcmV0dXJuIDcwMDAwMDsKICAgIH0sCiAgICByZW5ld2FibGVFbmVyZ3lNaW4oKSB7CiAgICAgIGNvbnN0IG1pblJlbmV3YWJsZSA9IE1hdGgubWluKC4uLnRoaXMuZmlsdGVyZWREYXRhLm1hcChkID0+IGQucmVuZXdhYmxlKSk7CiAgICAgIAogICAgICByZXR1cm4gbWluUmVuZXdhYmxlOwogICAgfSwKICAgIHhTY2FsZSgpIHsKICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5zdmdXaWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0XSkKICAgICAgICAuZG9tYWluKFt0aGlzLnJlbmV3YWJsZUVuZXJneU1pbiwgdGhpcy5yZW5ld2FibGVFbmVyZ3lNYXhdKTsKICAgIH0sCiAgICB5U2NhbGUoKSB7CiAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpCiAgICAgICAgLnJhbmdlUm91bmQoW3RoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20sIDBdKQogICAgICAgIC5kb21haW4oW3RoaXMubm9uUmVuZXdhYmxlRW5lcmd5TWluLCB0aGlzLm5vblJlbmV3YWJsZUVuZXJneU1heF0pOwogICAgfSwKICB9LAogIHdhdGNoOiB7CiAgICBlbmVyZ3lDYXBhY2l0eTogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIGxldCB4U2NhbGUgPSB0aGlzLnpvb21lZFhTY2FsZSB8fCB0aGlzLnhTY2FsZTsKICAgICAgICBsZXQgeVNjYWxlID0gdGhpcy56b29tZWRZU2NhbGUgfHwgdGhpcy55U2NhbGU7CiAgICAgICAgdGhpcy5kcmF3Q2hhcnQoeFNjYWxlLCB5U2NhbGUpOwogICAgICB9LAogICAgICBkZWVwOiB0cnVlLAogICAgfSwKICAgIGVuZXJneUdlbmVyYXRpb246IHsKICAgICAgaGFuZGxlcigpIHsKICAgICAgICBsZXQgeFNjYWxlID0gdGhpcy56b29tZWRYU2NhbGUgfHwgdGhpcy54U2NhbGU7CiAgICAgICAgbGV0IHlTY2FsZSA9IHRoaXMuem9vbWVkWVNjYWxlIHx8IHRoaXMueVNjYWxlOwogICAgICAgIHRoaXMuZHJhd0NoYXJ0KHhTY2FsZSwgeVNjYWxlKTsKICAgICAgfSwKICAgICAgZGVlcDogdHJ1ZSwKICAgIH0sCiAgICAvLyBmaWx0ZXJlZERhdGE6IHsKICAgIC8vICAgaGFuZGxlcigpIHsKICAgIC8vICAgICB0aGlzLmluaXRpYWxpemUoKTsKICAgIC8vICAgfSwKICAgIC8vICAgZGVlcDogdHJ1ZSwKICAgIC8vIH0sCiAgICAvLyB4U2NhbGU6IHsKICAgIC8vICAgaGFuZGxlcigpIHsKICAgIC8vICAgICBsZXQgeFNjYWxlID0gdGhpcy56b29tZWRYU2NhbGUgfHwgdGhpcy54U2NhbGU7CiAgICAvLyAgICAgbGV0IHlTY2FsZSA9IHRoaXMuem9vbWVkWVNjYWxlIHx8IHRoaXMueVNjYWxlOwogICAgLy8gICAgIC8vIHRoaXMucGFpbnRDaGFydCh4U2NhbGUsIHlTY2FsZSk7CiAgICAvLyAgIH0sCiAgICAvLyAgIGRlZXA6IHRydWUsCiAgICAvLyB9CiAgfSwKfQo="},{"version":3,"sources":["Scatterplot_2.vue"],"names":[],"mappings":";;AAmBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Scatterplot_2.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"vis-component\" ref=\"chart\">\n    <h6><h5>Renewable Energy Transition Project Identification: (Data for 2000 - 2022)</h5></h6>\n    <svg id=\"scatter2-svg\" :width=\"svgWidth\" :height=\"svgHeight\" @dblclick=\"resetZoom\">\n      <g class=\"chart-group\" ref=\"chartGroup\">\n        <g class=\"grid-background\" ref=\"gridBackground\"></g>\n        <g class=\"brush-group\" ref=\"brushGroup\"></g>\n        <g class=\"axis axis-x\" ref=\"axisX\"></g>\n        <g class=\"axis axis-y\" ref=\"axisY\"></g>\n        <g class=\"points-group\" ref=\"pointsGroup\"></g>\n      </g>\n    </svg>\n    \n    <div id=\"tooltip\" class=\"tooltip\" style=\"opacity:0;\"></div>\n  </div>\n</template>\n\n<script>\n\nimport * as d3 from 'd3';\n\nexport default {\n  name: 'Scatterplot_1',\n  props: {\n  },\n  data() {\n    const svgWidth = window.innerWidth * 4 / 12;\n    const svgHeight = window.innerHeight * 0.35;\n    return {\n      zoomedXScale: null,\n      zoomedYScale: null,\n      svgWidth: svgWidth,\n      svgHeight: svgHeight,\n      svgPadding: {\n        top: 5, right: 15, bottom: 60, left: 60,\n      },\n      significantChange: false,\n    }\n  },\n  mounted() {\n    this.drawChart(this.xScale, this.yScale);\n    this.addBrush();\n    this.initialize();\n    // this.paintChart(this.xScale, this.yScale);\n\n  },\n  methods: {\n    initialize() {\n      var localbrushedCountries = [];\n      this.filteredData.forEach(d => localbrushedCountries.push(d.id));\n    },\n    resetZoom() {\n      this.zoomedXScale = null;\n      this.zoomedYScale = null;\n      // this.paintChart(this.xScale, this.yScale);\n      this.drawChart(this.xScale, this.yScale);\n      this.initialize()\n    },\n    // called for each updage\n    drawChart(xScale, yScale) {\n      xScale = xScale || this.xScale;\n      yScale = yScale || this.yScale;\n\n      // Update axes\n      this.drawXAxis(xScale);\n      this.drawYAxis(yScale);\n      \n      d3.select(this.$refs.chartGroup)\n        .attr('transform', `translate(${this.svgPadding.left},${this.svgPadding.top})`);\n      this.drawPoints(xScale, yScale);\n      // this.paintChart(xScale, yScale);\n    },\n    // brush for showing on choroplethmap\n    addBrush() {\n      this.brush = d3.brush()\n        .extent([[0,0], [this.svgWidth - this.svgPadding.left - this.svgPadding.right, \n          this.svgHeight - this.svgPadding.bottom - this.svgPadding.top]])\n        .on('end', this.onBrush);\n      \n      d3.select(this.$refs.brushGroup)\n        .attr('class', 'brush')\n        .call(this.brush);\n    },\n    // get states in brush\n    onBrush(event) {\n      this.significantChange = true;\n      var selection = event.selection;\n      var localbrushedCountries = [];\n      var x0,x1,y0,y1,idleTimeout;\n      if (!selection) {\n        // Reset zoom and clear brushed countries\n        this.filteredData.forEach(d => localbrushedCountries.push(d.id));\n        if (!idleTimeout) return idleTimeout = setTimeout(() => {\n          idleTimeout = null\n        }, 1)    \n      } else {\n        // Calculate new scales for zoom\n        if (this.zoomedXScale) {\n          x0 = this.zoomedXScale.invert(selection[0][0]);\n          x1 = this.zoomedXScale.invert(selection[1][0]);\n          y0 = this.zoomedYScale.invert(selection[1][1]);\n          y1 = this.zoomedYScale.invert(selection[0][1]);\n        } else {\n          x0 = this.xScale.invert(selection[0][0]);\n          x1 = this.xScale.invert(selection[1][0]);\n          y0 = this.yScale.invert(selection[1][1]);\n          y1 = this.yScale.invert(selection[0][1]);\n        }\n\n        this.zoomedXScale = d3.scaleLinear().domain([x0, x1]).range([0, this.svgWidth - this.svgPadding.left - this.svgPadding.right]);\n        this.zoomedYScale = d3.scaleLinear().domain([y0, y1]).range([this.svgHeight - this.svgPadding.top - this.svgPadding.bottom, 0]);\n\n        this.drawChart(this.zoomedXScale, this.zoomedYScale);\n\n        this.filteredData.forEach(d => {\n          if (d.energyGeneration >= y0 && d.energyGeneration <= y1 && d.energyCapacity >= x0 && d.energyCapacity <= x1) {\n            localbrushedCountries.push(d.id);\n          }\n        });\n        \n      }\n\n      // this.paintChart(this.zoomedXScale, this.zoomedYScale);\n\n      d3.select('#scatter2-svg').select(\".brush\").call(this.brush.move, null);\n    },\n    drawXAxis(xScale) {\n      const xAxisGroup = d3.select(this.$refs.axisX)\n        .attr('transform', `translate(0, ${this.svgHeight - this.svgPadding.top - this.svgPadding.bottom})`)\n        .call(d3.axisBottom(xScale));\n\n      // Rotate the ticks\n      xAxisGroup.selectAll(\".tick text\")\n      .attr(\"transform\", \"rotate(50)\")\n      .attr(\"x\", 9)\n      .attr(\"y\", 0)\n      .style(\"text-anchor\", \"start\");\n\n      // Position the axis label\n      xAxisGroup.append('text')\n      .attr('class', 'x-axis-label')\n      .attr('x', this.svgWidth / 2)\n      .attr('y', this.svgPadding.bottom - 5)\n\n      \n      .style('text-anchor', 'middle')\n      .style('fill', 'black')\n      .style('font-size', '12px')\n      .text('Renewable Energy Capacity');\n    },\n    drawYAxis(yScale) {\n      const yAxisGroup = d3.select(this.$refs.axisY)\n        .attr('transform', `translate(0, 0)`)\n        .call(d3.axisLeft(yScale))\n        .style('font-size', '10px');\n\n      // Rotate the ticks\n      yAxisGroup.selectAll('.tick text')\n        .attr('transform', 'rotate(-50)')\n        .style('text-anchor', 'end');\n\n      // Remove any existing y-axis label before adding a new one\n      yAxisGroup.selectAll('.y-axis-label').remove();\n\n      // Add new y-axis label\n      yAxisGroup.append('text')\n        .attr('class', 'y-axis-label')\n        .attr('transform', 'rotate(-90)')\n        .attr('y', -this.svgPadding.left + 15)\n        .attr('x', -this.svgHeight / 2) // Position in the middle of y-axis\n        .style('text-anchor', 'middle') // Center the text on its x position\n        .style('fill', 'black')\n        .style('font-size', '12px')\n        .text('Non-Renewable Energy Capacity');\n    },\n\n\n    // add country points on scatterplot\n    drawPoints(xScale, yScale) {\n      const pointsGroup = d3.select(this.$refs.pointsGroup);\n      const tooltip = d3.select(\"#tooltip\");\n      const transition = this.significantChange? d3.transition().duration(750) : d3.transition().duration(0);\n\n      const xRange = xScale.range();\n      const yRange = yScale.range();\n      const inBoundData = this.filteredData.filter(d => {\n\n        const cx = xScale(d.renewable);\n        const cy = yScale(d.nonRenewable);\n        \n\n\n        return cx >= xRange[0] && cx <= xRange[1] && cy <= yRange[0] && cy >= yRange[1];\n      });\n      pointsGroup.selectAll('.point')\n        .data(inBoundData, function(d) { return d.id; })\n        .join(\n          enter => enter.append('circle')\n                        .attr('class', 'point')\n                        .attr('cx', d => xScale(d.renewable))\n                        .attr('cy', this.svgHeight - this.svgPadding.bottom) // start from bottom\n                        .attr('r', 6) // start from zero radius\n                        .call(enter => enter.transition(transition)\n                            .attr('cy', d => yScale(d.nonRenewable))\n                            .attr('r', 6)),\n          update => update.call(update => update.transition(transition)\n                              .attr('cx', d => xScale(d.renewable))\n                              .attr('cy', d => yScale(d.nonRenewable))),\n          exit => exit.call(exit => exit.transition(transition)\n                            .attr('cy', this.svgHeight - this.svgPadding.bottom)\n                            .attr('r', 0)\n                            .remove())\n        )\n        .attr('fill', \"rgb(1, 39, 39)\")\n        .on('mouseover', function(event, d) {\n          d3.select(this)\n            .raise()\n            .attr('stroke', 'green')\n            .attr('stroke-width', 2);\n          let renewableEnergyTemp = d.renewable === 0 ? 'No Data' : d.renewable.toFixed(2);\n          let nonRenewableEnergyTemp = d.nonRenewable === 0 ? 'No Data' : d.nonRenewable.toFixed(2);\n          tooltip.transition()\n            .duration(200)\n            .style('opacity', 1);\n          tooltip.html(`\n            <table>\n              <tr><td class=\"label\">Country:</td>         <td class=\"country_value\">${d.country}</td></tr>\n              <tr><td class=\"label\">Non-Renewable Energy:</td>     <td class=\"value\">${nonRenewableEnergyTemp}</td></tr>\n              <tr><td class=\"label\">Renewable Energy:</td>        <td class=\"value\">${renewableEnergyTemp}</td></tr>\n            </table>\n          `)\n          .style('left', (event.clientX - 275) + 'px')\n          .style('top', (event.clientY - 100) + 'px');\n        })\n        .on('mouseout', function() {\n          d3.select(this)\n            .attr('r', 6)\n            .attr('stroke', 'none')\n            .attr('stroke-width', 0);\n          tooltip.transition()\n            .duration(500)\n            .style('opacity', 0);\n        })\n        \n      this.significantChange = false;\n    },\n      \n    // coloring the grid\n    // paintChart(xScale, yScale) {\n    //   xScale = xScale || this.xScale;\n    //   yScale = yScale || this.yScale;\n    //   const background = d3.select(this.$refs.gridBackground);\n    //   background.selectAll('rect').remove()\n    //   background.selectAll('#plot-area-clip-background').remove()\n    //   const colors = [\n    //     \"rgb(230, 230, 230)\",\n    //     \"rgb(220, 220, 220)\",\n    //     \"rgb(230, 230, 230)\",\n    //     \"rgb(220, 220, 220)\", \n    //     \"rgb(230, 230, 230)\", \n    //     \"rgb(220, 220, 220)\",\n    //     \"rgb(230, 230, 230)\", \n    //     \"rgb(220, 220, 220)\",\n    //     \"rgb(230, 230, 230)\",\n    //   ];\n    //   background.append(\"defs\").append(\"clipPath\")\n    //     .attr(\"id\", \"plot-area-clip-background\")\n    //     .append(\"rect\")\n    //     .attr(\"width\", this.svgWidth - this.svgPadding.left - this.svgPadding.right)\n    //     .attr(\"height\", this.svgHeight - this.svgPadding.top - this.svgPadding.bottom);\n    //   const xFirstTick = this.renewableEnergyMin + (this.renewableEnergyMax - this.renewableEnergyMin)/3;\n    //   const xSecondTick = this.renewableEnergyMin + 2*(this.renewableEnergyMax - this.renewableEnergyMin)/3;\n    //   const xValues = [this.renewableEnergyMin, xFirstTick, xSecondTick, this.renewableEnergyMax];\n    //   const yFirstTick = this.nonRenewableEnergyMin + (this.nonRenewableEnergyMax - this.nonRenewableEnergyMin)/3;\n    //   const ySecondTick = this.nonRenewableEnergyMin + 2*(this.nonRenewableEnergyMax - this.nonRenewableEnergyMin)/3;\n    //   const yValues = [this.nonRenewableEnergyMin, yFirstTick, ySecondTick,this.nonRenewableEnergyMax];\n    //   for (let i = 0; i < yValues.length - 1; i++) {\n    //     for (let j = 0; j < xValues.length - 1; j++) {\n    //       background.append('rect')\n    //         .attr('x', xScale(xValues[j]))\n    //         .attr('y', yScale(yValues[i+1]))\n    //         .attr(\"clip-path\", \"url(#plot-area-clip-background)\")\n    //         .attr('fill', colors[j + i * 3])\n    //         .attr('opacity', 0) // Start with an opacity of 0 for the transition\n    //         .attr('width', xScale(xValues[j+1]) - xScale(xValues[j]))\n    //         .attr('height', yScale(yValues[i]) - yScale(yValues[i+1]))\n    //         .attr('opacity', 1);\n    //     }\n    //   }\n    // },\n    sumEnergyCapacityByCountry(data) {\n      // Assuming each entry in `data` has a `country` field and a `capacity` field\n      const summedData = data.reduce((acc, item) => {\n        const country = item.country;\n        if (!acc[country]) {\n          acc[country] = { ...item, capacity: 0 }; // copy all properties\n        }\n        acc[country].capacity += parseFloat(item.capacity) || 0;\n        return acc;\n      }, {});\n\n      // Convert the object back into an array\n      return Object.values(summedData);\n    },\n  },\n  computed: {\n    filteredData() {\n      return this.combinedData.filter(d => d.energyCapacity !== 0 && d.energyCapacity !== 0);\n    },\n    combinedData() {\n      let totalRenewable = this.energyCapacity\n        .filter(ec => ec['energyType'] === 'Total Renewable')\n        .filter(ec => ec.id)\n        .reduce((accumulator, current) => {\n          const valueToAdd = Number(current.value) || 0;\n          if (accumulator[current.id]) {\n            accumulator[current.id].value += valueToAdd;\n          } else {\n            accumulator[current.id] = {\n              id: current.id,\n              country: current.country,\n              value: valueToAdd\n            };\n          }\n          return accumulator;\n          }, {});\n      let totalNonRenewable = this.energyCapacity\n        .filter(ec => ec['energyType'] === 'Total Non-Renewable')\n        .filter(ec => ec.id)\n        .reduce((accumulator, current) => {\n          const valueToAdd = Number(current.value) || 0;\n          if (accumulator[current.id]) {\n            accumulator[current.id].value += valueToAdd;\n          } else {\n            accumulator[current.id] = {\n              id: current.id,\n              country: current.country,\n              value: valueToAdd\n            };\n          }\n          return accumulator;\n          }, {});\n      \n      let renewableArray = Object.values(totalRenewable);\n      let nonRenewableArray = Object.values(totalNonRenewable);\n      let combined = renewableArray.map(rn => {\n        let totalNonRenewableData = nonRenewableArray.find(nr => nr.id === rn.id);\n        return {\n          id: rn.id,\n          country: rn.country,\n          renewable: rn.value,\n          nonRenewable: totalNonRenewableData? totalNonRenewableData.value: 0,\n        };\n      });\n      return combined;\n    },\n    energyCapacity: {\n      get() {\n        return this.$store.getters.energyCapacity;\n      }\n    },\n    energyGeneration: {\n      get() {\n        return this.$store.getters.energyGeneration;\n      }\n    },\n    nonRenewableEnergyMax() {\n      const maxNonRenewable = Math.max(...this.filteredData.map(d => d.nonRenewable));\n      let roundedMax;\n      if (maxNonRenewable > 1000000) {\n        roundedMax = Math.ceil(maxNonRenewable / 100000) * 100000;\n      } else if (maxNonRenewable > 100000) {\n        roundedMax = Math.ceil(maxNonRenewable / 10000) * 10000;\n      } else if (maxNonRenewable > 10000) {\n        roundedMax = Math.ceil(maxNonRenewable / 1000) * 1000;\n      } else {\n        // No rounding needed\n        roundedMax = maxNonRenewable;\n      }\n      return roundedMax;\n      // return 1300000;\n    },\n    nonRenewableEnergyMin() {\n      const minNonRenewable = Math.min(...this.filteredData.map(d => d.nonRenewable));\n      return minNonRenewable;\n    },\n    renewableEnergyMax() {\n      const maxRenewable = Math.max(...this.filteredData.map(d => d.renewable));\n      let roundedMax;\n      if (maxRenewable > 1000000) {\n        roundedMax = Math.ceil(maxRenewable / 100000) * 100000;\n      } else if (maxRenewable > 100000) {\n        roundedMax = Math.ceil(maxRenewable / 10000) * 10000;\n      } else if (maxRenewable > 10000) {\n        roundedMax = Math.ceil(maxRenewable / 1000) * 1000;\n      } else {\n        // No rounding needed\n        roundedMax = maxRenewable;\n      }\n      return roundedMax;\n      // return 700000;\n    },\n    renewableEnergyMin() {\n      const minRenewable = Math.min(...this.filteredData.map(d => d.renewable));\n      \n      return minRenewable;\n    },\n    xScale() {\n      return d3.scaleLinear()\n        .rangeRound([0, this.svgWidth - this.svgPadding.left - this.svgPadding.right])\n        .domain([this.renewableEnergyMin, this.renewableEnergyMax]);\n    },\n    yScale() {\n      return d3.scaleLinear()\n        .rangeRound([this.svgHeight - this.svgPadding.top - this.svgPadding.bottom, 0])\n        .domain([this.nonRenewableEnergyMin, this.nonRenewableEnergyMax]);\n    },\n  },\n  watch: {\n    energyCapacity: {\n      handler() {\n        let xScale = this.zoomedXScale || this.xScale;\n        let yScale = this.zoomedYScale || this.yScale;\n        this.drawChart(xScale, yScale);\n      },\n      deep: true,\n    },\n    energyGeneration: {\n      handler() {\n        let xScale = this.zoomedXScale || this.xScale;\n        let yScale = this.zoomedYScale || this.yScale;\n        this.drawChart(xScale, yScale);\n      },\n      deep: true,\n    },\n    // filteredData: {\n    //   handler() {\n    //     this.initialize();\n    //   },\n    //   deep: true,\n    // },\n    // xScale: {\n    //   handler() {\n    //     let xScale = this.zoomedXScale || this.xScale;\n    //     let yScale = this.zoomedYScale || this.yScale;\n    //     // this.paintChart(xScale, yScale);\n    //   },\n    //   deep: true,\n    // }\n  },\n}\n</script>\n\n<style>\n</style>\n"]}]}