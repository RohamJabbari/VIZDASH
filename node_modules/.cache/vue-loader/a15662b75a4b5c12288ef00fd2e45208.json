{"remainingRequest":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/src/components/Scatterplot_1.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/src/components/Scatterplot_1.vue","mtime":1705768136798},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/node_modules/cache-loader/dist/cjs.js","mtime":1705744300535},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/node_modules/babel-loader/lib/index.js","mtime":1705744300565},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/node_modules/cache-loader/dist/cjs.js","mtime":1705744300535},{"path":"/Users/rohamjabbari/Desktop/VIS/A5/vis-vue-d3/node_modules/vue-loader/lib/index.js","mtime":1705744299123}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgppbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ1NjYXR0ZXJwbG90XzEnLAogIHByb3BzOiB7CiAgfSwKICBkYXRhKCkgewogICAgY29uc3Qgc3ZnV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIDQgLyAxMjsKICAgIGNvbnN0IHN2Z0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuMzU7CiAgICByZXR1cm4gewogICAgICB6b29tZWRYU2NhbGU6IG51bGwsCiAgICAgIHpvb21lZFlTY2FsZTogbnVsbCwKICAgICAgc3ZnV2lkdGg6IHN2Z1dpZHRoLAogICAgICBzdmdIZWlnaHQ6IHN2Z0hlaWdodCwKICAgICAgc3ZnUGFkZGluZzogewogICAgICAgIHRvcDogNSwgcmlnaHQ6IDE1LCBib3R0b206IDYwLCBsZWZ0OiA2MCwKICAgICAgfSwKICAgIH0KICB9LAogIG1vdW50ZWQoKSB7CiAgICB0aGlzLnBhaW50Q2hhcnQodGhpcy54U2NhbGUsIHRoaXMueVNjYWxlKTsKICAgIHRoaXMuZHJhd0NoYXJ0KHRoaXMueFNjYWxlLCB0aGlzLnlTY2FsZSk7CiAgICB0aGlzLmRyYXdYQXhpcyh0aGlzLnhTY2FsZSk7CiAgICB0aGlzLmRyYXdZQXhpcyh0aGlzLnlTY2FsZSk7CiAgICB0aGlzLmFkZEJydXNoKCk7CiAgICB0aGlzLmluaXRpYWxpemUoKTsKCiAgICBkMy5zZWxlY3QoJyNzY2F0dGVyMS1zdmcnKS5vbignY2xpY2snLCAoZXZlbnQpID0+IHsKICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZDMuc2VsZWN0KCcjc2NhdHRlcjEtc3ZnJykubm9kZSgpKSB7CiAgICAgICAgdGhpcy5yZW1vdmVTZWxlY3Rpb24oKTsKICAgICAgfQogICAgfSk7CiAgfSwKICBtZXRob2RzOiB7CiAgICByZW1vdmVTZWxlY3Rpb24oKSB7CiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgncmVtb3ZlU2VsZWN0ZWRDb3VudHJpZXMnKTsKICAgIH0sCiAgICBpbml0aWFsaXplKCkgewogICAgICB2YXIgbG9jYWxicnVzaGVkQ291bnRyaWVzID0gW107CiAgICAgIHRoaXMuZmlsdGVyZWREYXRhLmZvckVhY2goZCA9PiBsb2NhbGJydXNoZWRDb3VudHJpZXMucHVzaChkLmlkKSk7CiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnY2hhbmdlQnJ1c2hlZENvdW50cmllcycsIGxvY2FsYnJ1c2hlZENvdW50cmllcyk7CiAgICB9LAogICAgcmVzZXRab29tKCkgewogICAgICB0aGlzLnpvb21lZFhTY2FsZSA9IG51bGw7CiAgICAgIHRoaXMuem9vbWVkWVNjYWxlID0gbnVsbDsKICAgICAgdGhpcy5wYWludENoYXJ0KHRoaXMueFNjYWxlLCB0aGlzLnlTY2FsZSk7CiAgICAgIHRoaXMuZHJhd0NoYXJ0KHRoaXMueFNjYWxlLCB0aGlzLnlTY2FsZSk7CiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpCiAgICB9LAogICAgLy8gY2FsbGVkIGZvciBlYWNoIHVwZGFnZQogICAgZHJhd0NoYXJ0KHhTY2FsZSwgeVNjYWxlKSB7CiAgICAgIHhTY2FsZSA9IHhTY2FsZSB8fCB0aGlzLnhTY2FsZTsKICAgICAgeVNjYWxlID0geVNjYWxlIHx8IHRoaXMueVNjYWxlOwoKICAgICAgLy8gVXBkYXRlIGF4ZXMKICAgICAgdGhpcy5kcmF3WEF4aXMoeFNjYWxlKTsKICAgICAgdGhpcy5kcmF3WUF4aXMoeVNjYWxlKTsKICAgICAgCiAgICAgIGQzLnNlbGVjdCh0aGlzLiRyZWZzLmNoYXJ0R3JvdXApCiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLnN2Z1BhZGRpbmcubGVmdH0sJHt0aGlzLnN2Z1BhZGRpbmcudG9wfSlgKTsKICAgICAgdGhpcy5kcmF3UG9pbnRzKHhTY2FsZSwgeVNjYWxlKTsKICAgIH0sCiAgICAvLyBicnVzaCBmb3Igc2hvd2luZyBvbiBjaG9yb3BsZXRobWFwCiAgICBhZGRCcnVzaCgpIHsKICAgICAgdGhpcy5icnVzaCA9IGQzLmJydXNoKCkKICAgICAgICAuZXh0ZW50KFtbMCwwXSwgW3RoaXMuc3ZnV2lkdGggLSB0aGlzLnN2Z1BhZGRpbmcubGVmdCAtIHRoaXMuc3ZnUGFkZGluZy5yaWdodCwgCiAgICAgICAgICB0aGlzLnN2Z0hlaWdodCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20gLSB0aGlzLnN2Z1BhZGRpbmcudG9wXV0pCiAgICAgICAgLm9uKCdlbmQnLCB0aGlzLm9uQnJ1c2gpOwogICAgICAKICAgICAgZDMuc2VsZWN0KHRoaXMuJHJlZnMuYnJ1c2hHcm91cCkKICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2gnKQogICAgICAgIC5jYWxsKHRoaXMuYnJ1c2gpOwogICAgfSwKICAgIC8vIGdldCBzdGF0ZXMgaW4gYnJ1c2gKICAgIG9uQnJ1c2goZXZlbnQpIHsKICAgICAgY29uc3QgZmlsdGVyZWRQb2ludHMgPSB0aGlzLmZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PiB0aGlzLmJydXNoZWRDb3VudHJpZXMuaW5jbHVkZXMoZC5pZCkpOwogICAgICB2YXIgc2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uOwogICAgICB2YXIgbG9jYWxicnVzaGVkQ291bnRyaWVzID0gW107CiAgICAgIAogICAgICB2YXIgeDAseDEseTAseTEsaWRsZVRpbWVvdXQ7CiAgICAgIGlmICghc2VsZWN0aW9uKSB7CiAgICAgICAgZmlsdGVyZWRQb2ludHMuZm9yRWFjaChkID0+IGxvY2FsYnJ1c2hlZENvdW50cmllcy5wdXNoKGQuaWQpKTsKICAgICAgICBpZiAoIWlkbGVUaW1lb3V0KSByZXR1cm4gaWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGlkbGVUaW1lb3V0ID0gbnVsbAogICAgICAgIH0sIDEpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc2NhbGVzIGZvciB6b29tCiAgICAgICAgaWYgKHRoaXMuem9vbWVkWFNjYWxlKSB7CiAgICAgICAgICB4MCA9IHRoaXMuem9vbWVkWFNjYWxlLmludmVydChzZWxlY3Rpb25bMF1bMF0pOwogICAgICAgICAgeDEgPSB0aGlzLnpvb21lZFhTY2FsZS5pbnZlcnQoc2VsZWN0aW9uWzFdWzBdKTsKICAgICAgICAgIHkwID0gdGhpcy56b29tZWRZU2NhbGUuaW52ZXJ0KHNlbGVjdGlvblsxXVsxXSk7CiAgICAgICAgICB5MSA9IHRoaXMuem9vbWVkWVNjYWxlLmludmVydChzZWxlY3Rpb25bMF1bMV0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB4MCA9IHRoaXMueFNjYWxlLmludmVydChzZWxlY3Rpb25bMF1bMF0pOwogICAgICAgICAgeDEgPSB0aGlzLnhTY2FsZS5pbnZlcnQoc2VsZWN0aW9uWzFdWzBdKTsKICAgICAgICAgIHkwID0gdGhpcy55U2NhbGUuaW52ZXJ0KHNlbGVjdGlvblsxXVsxXSk7CiAgICAgICAgICB5MSA9IHRoaXMueVNjYWxlLmludmVydChzZWxlY3Rpb25bMF1bMV0pOwogICAgICAgIH0KCiAgICAgICAgdGhpcy56b29tZWRYU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihbeDAsIHgxXSkucmFuZ2UoWzAsIHRoaXMuc3ZnV2lkdGggLSB0aGlzLnN2Z1BhZGRpbmcubGVmdCAtIHRoaXMuc3ZnUGFkZGluZy5yaWdodF0pOwogICAgICAgIHRoaXMuem9vbWVkWVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oW3kwLCB5MV0pLnJhbmdlKFt0aGlzLnN2Z0hlaWdodCAtIHRoaXMuc3ZnUGFkZGluZy50b3AgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tLCAwXSk7CgogICAgICAgIC8vIFJlZHJhdyBjaGFydCB3aXRoIG5ldyBzY2FsZXMKICAgICAgICB0aGlzLmRyYXdDaGFydCh0aGlzLnpvb21lZFhTY2FsZSwgdGhpcy56b29tZWRZU2NhbGUpOwoKICAgICAgICAvLyBGaWx0ZXIgYnJ1c2hlZCBjb3VudHJpZXMKICAgICAgICBmaWx0ZXJlZFBvaW50cy5mb3JFYWNoKGQgPT4gewogICAgICAgICAgaWYgKGQuY2FyYm9uU3RvY2tzID49IHkwICYmIGQuY2FyYm9uU3RvY2tzIDw9IHkxICYmIGQubGFuZENvdmVyID49IHgwICYmIGQubGFuZENvdmVyIDw9IHgxKSB7CiAgICAgICAgICAgIGxvY2FsYnJ1c2hlZENvdW50cmllcy5wdXNoKGQuaWQpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIAogICAgICB9CgogICAgICB0aGlzLnBhaW50Q2hhcnQodGhpcy56b29tZWRYU2NhbGUsIHRoaXMuem9vbWVkWVNjYWxlKQoKICAgICAgZDMuc2VsZWN0KCcjc2NhdHRlcjEtc3ZnJykuc2VsZWN0KCIuYnJ1c2giKS5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgbnVsbCkKCiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnY2hhbmdlQnJ1c2hlZENvdW50cmllcycsIGxvY2FsYnJ1c2hlZENvdW50cmllcyk7CiAgICB9LAogICAgLy8gWC1heGlzCiAgICBkcmF3WEF4aXMoeFNjYWxlKSB7CiAgICAgIGNvbnN0IHhBeGlzR3JvdXAgPSBkMy5zZWxlY3QodGhpcy4kcmVmcy5heGlzWCkKICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke3RoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b219KWApCiAgICAgICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh4U2NhbGUpKQogICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzEwJyk7CgogICAgICBjb25zdCB4QXhpc1RleHQgPSB4QXhpc0dyb3VwLnNlbGVjdEFsbCgnLngtYXhpcy1sYWJlbCcpLmRhdGEoWydMYW5kIENvdmVyIEluZGV4IChDb21wYXJlZCB0byAyMDE1KSddKTsKCiAgICAgIHhBeGlzVGV4dC5lbnRlcigpCiAgICAgICAgLmFwcGVuZCgndGV4dCcpCiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3gtYXhpcy1sYWJlbCcpCiAgICAgICAgLm1lcmdlKHhBeGlzVGV4dCkKICAgICAgICAuYXR0cigneCcsIHRoaXMuc3ZnV2lkdGgvMiArIHRoaXMuc3ZnUGFkZGluZy5sZWZ0ICsgdGhpcy5zdmdQYWRkaW5nLnJpZ2h0ICsgNSkKICAgICAgICAuYXR0cigneScsIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20gLSAxMCkKICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJykKICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnYmxhY2snKQogICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzE0cHgnKQogICAgICAgIC50ZXh0KGQgPT4gZCk7CiAgICAgIH0sCiAgICAvLyBZLWF4aXMKICAgIGRyYXdZQXhpcyh5U2NhbGUpIHsKICAgICAgY29uc3QgeUF4aXNHcm91cCA9IGQzLnNlbGVjdCh0aGlzLiRyZWZzLmF4aXNZKQogICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCAwLCAwKWApCiAgICAgICAgLmNhbGwoZDMuYXhpc0xlZnQoeVNjYWxlKSkKICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMCcpOwogICAgICAgIAogICAgICBjb25zdCB5QXhpc1RleHQgPSB5QXhpc0dyb3VwLnNlbGVjdEFsbCgnLnktYXhpcy1sYWJlbCcpLmRhdGEoWydDYXJib24gU3RvY2tzJ10pOwoKICAgICAgeUF4aXNUZXh0LmVudGVyKCkKICAgICAgICAuYXBwZW5kKCd0ZXh0JykKICAgICAgICAuYXR0cignY2xhc3MnLCAneS1heGlzLWxhYmVsJykKICAgICAgICAubWVyZ2UoeUF4aXNUZXh0KQogICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKC05MCknKQogICAgICAgIC5hdHRyKCd5JywgLXRoaXMuc3ZnUGFkZGluZy5sZWZ0ICsgNSkKICAgICAgICAuYXR0cigneCcsIC10aGlzLnN2Z0hlaWdodC80ICsgdGhpcy5zdmdQYWRkaW5nLnRvcCArIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20gKyAxMCkKICAgICAgICAuYXR0cignZHknLCAnMC43MWVtJykKICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJykgCiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnYmxhY2snKQogICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzE0cHgnKQogICAgICAgIC50ZXh0KCJDYXJib24gU3RvY2tzIEluZGV4IChDb21wYXJlZCB0byAxOTkyKSIpOwogICAgfSwKICAgIC8vIGFkZCBjb3VudHJ5IHBvaW50cyBvbiBzY2F0dGVycGxvdAogICAgZHJhd1BvaW50cyh4U2NhbGUsIHlTY2FsZSkgewogICAgICBjb25zdCBwb2ludHNHcm91cCA9IGQzLnNlbGVjdCh0aGlzLiRyZWZzLnBvaW50c0dyb3VwKTsKICAgICAgY29uc3QgZmlsdGVyZWRQb2ludHMgPSB0aGlzLmZpbHRlcmVkRGF0YS5maWx0ZXIoZCA9PiB0aGlzLmJydXNoZWRDb3VudHJpZXMuaW5jbHVkZXMoZC5pZCkpOwogICAgICBjb25zb2xlLmxvZygnZmlsdGVyZWQnKTsKICAgICAgY29uc29sZS5sb2coZmlsdGVyZWRQb2ludHMpOwoKICAgICAgY29uc3QgdG9vbHRpcCA9IGQzLnNlbGVjdCgiI3Rvb2x0aXAiKTsKICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IGQzLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApOwogICAgICBmaWx0ZXJlZFBvaW50cy5zb3J0KChhLCBiKSA9PiB7CiAgICAgICAgY29uc3QgYVNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZENvdW50cmllcy5pbmNsdWRlcyhhLmlkKTsKICAgICAgICBjb25zdCBiU2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkQ291bnRyaWVzLmluY2x1ZGVzKGIuaWQpOwogICAgICAgIHJldHVybiBhU2VsZWN0ZWQgPT09IGJTZWxlY3RlZCA/IDAgOiBhU2VsZWN0ZWQgPyAxIDogLTE7CiAgICAgIH0pOwogICAgICBjb25zdCB4UmFuZ2UgPSB4U2NhbGUucmFuZ2UoKTsKICAgICAgY29uc3QgeVJhbmdlID0geVNjYWxlLnJhbmdlKCk7CiAgICAgIGNvbnN0IGluQm91bmREYXRhID0gZmlsdGVyZWRQb2ludHMuZmlsdGVyKGQgPT4gewoKICAgICAgICBjb25zdCBjeCA9IHhTY2FsZShkLmxhbmRDb3Zlcik7CiAgICAgICAgY29uc3QgY3kgPSB5U2NhbGUoZC5jYXJib25TdG9ja3MpOwogICAgICAgIAoKCiAgICAgICAgcmV0dXJuIGN4ID49IHhSYW5nZVswXSAmJiBjeCA8PSB4UmFuZ2VbMV0gJiYgY3kgPD0geVJhbmdlWzBdICYmIGN5ID49IHlSYW5nZVsxXTsKICAgICAgfSk7CgogICAgICBjb25zb2xlLmxvZygnYm91bmRlZCcpOwogICAgICBjb25zb2xlLmxvZyhpbkJvdW5kRGF0YSk7CgoKICAgICAgcG9pbnRzR3JvdXAuc2VsZWN0QWxsKCcucG9pbnQnKQogICAgICAgIC5kYXRhKGluQm91bmREYXRhLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmlkOyB9KQogICAgICAgIC5qb2luKAogICAgICAgICAgZW50ZXIgPT4gZW50ZXIuYXBwZW5kKCdjaXJjbGUnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnQnKQogICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IHhTY2FsZShkLmxhbmRDb3ZlcikpCiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHRoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLmJvdHRvbSkgLy8gc3RhcnQgZnJvbSBib3R0b20KICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA2KSAvLyBzdGFydCBmcm9tIHplcm8gcmFkaXVzCiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGVudGVyID0+IGVudGVyLnRyYW5zaXRpb24odHJhbnNpdGlvbikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4geVNjYWxlKGQuY2FyYm9uU3RvY2tzKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgNikpLAogICAgICAgICAgdXBkYXRlID0+IHVwZGF0ZS5jYWxsKHVwZGF0ZSA9PiB1cGRhdGUudHJhbnNpdGlvbih0cmFuc2l0aW9uKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiB4U2NhbGUoZC5sYW5kQ292ZXIpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiB5U2NhbGUoZC5jYXJib25TdG9ja3MpKSksCiAgICAgICAgICBleGl0ID0+IGV4aXQuY2FsbChleGl0ID0+IGV4aXQudHJhbnNpdGlvbih0cmFuc2l0aW9uKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgdGhpcy5zdmdIZWlnaHQgLSB0aGlzLnN2Z1BhZGRpbmcuYm90dG9tKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA2KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpKQogICAgICAgICkKICAgICAgICAuYXR0cignZmlsbCcsIGQgPT4gdGhpcy5zZWxlY3RlZENvdW50cmllcy5pbmNsdWRlcyhkLmlkKSA/ICJyZ2IoMjUzLCAyNTUsIDE4MSkiIDogInJnYigxLCAzOSwgMzkpIikKICAgICAgICAKICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGV2ZW50LCBkKSB7CiAgICAgICAgICBkMy5zZWxlY3QodGhpcykKICAgICAgICAgICAgLnJhaXNlKCkKICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdhcXVhJykKICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpOwogICAgICAgICAgbGV0IGxhbmRDb3ZlclRlbXAgPSBkLmxhbmRDb3ZlciA9PT0gMCA/ICdObyBEYXRhJyA6IGQubGFuZENvdmVyLnRvRml4ZWQoMik7CiAgICAgICAgICBsZXQgY2FyYm9uU3RvY2tzVGVtcCA9IGQuY2FyYm9uU3RvY2tzID09PSAwID8gJ05vIERhdGEnIDogZC5jYXJib25TdG9ja3MudG9GaXhlZCgyKTsKICAgICAgICAgIGxldCBkaXNhc3RlcnNGcmVxVGVtcCA9IGQuZGlzYXN0ZXJzRnJlcSA9PT0gLTEgPyAnTm8gRGF0YScgOiBkLmRpc2FzdGVyc0ZyZXE7CiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKQogICAgICAgICAgICAuZHVyYXRpb24oMjAwKQogICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTsKICAgICAgICAgIHRvb2x0aXAuaHRtbChgCiAgICAgICAgICAgIDx0YWJsZT4KICAgICAgICAgICAgICA8dHI+PHRkIGNsYXNzPSJsYWJlbCI+Q291bnRyeTo8L3RkPiAgICAgICAgIDx0ZCBjbGFzcz0iY291bnRyeV92YWx1ZSI+JHtkLmNvdW50cnl9PC90ZD48L3RyPgogICAgICAgICAgICAgIDx0cj48dGQgY2xhc3M9ImxhYmVsIj5DYXJib24gU3RvY2tzOjwvdGQ+ICAgICA8dGQgY2xhc3M9InZhbHVlIj4ke2NhcmJvblN0b2Nrc1RlbXB9PC90ZD48L3RyPgogICAgICAgICAgICAgIDx0cj48dGQgY2xhc3M9ImxhYmVsIj5MYW5kIENvdmVyOjwvdGQ+ICAgICAgICA8dGQgY2xhc3M9InZhbHVlIj4ke2xhbmRDb3ZlclRlbXB9PC90ZD48L3RyPgogICAgICAgICAgICAgIDx0cj48dGQgY2xhc3M9ImxhYmVsIj5EaXNhc3RlcnMgRnJlcXVlbmN5OjwvdGQ+ICAgICA8dGQgY2xhc3M9InZhbHVlIj4ke2Rpc2FzdGVyc0ZyZXFUZW1wfTwvdGQ+PC90cj4KICAgICAgICAgICAgPC90YWJsZT4KICAgICAgICAgIGApCiAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCAoZXZlbnQuY2xpZW50WCAtIDI3NSkgKyAncHgnKQogICAgICAgICAgLnN0eWxlKCd0b3AnLCAoZXZlbnQuY2xpZW50WSAtIDEwMCkgKyAncHgnKTsKICAgICAgICB9KQogICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHsKICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKQogICAgICAgICAgICAuYXR0cigncicsIDYpCiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnbm9uZScpCiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTsKICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpCiAgICAgICAgICAgIC5kdXJhdGlvbig1MDApCiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApOwogICAgICAgIH0pCiAgICAgICAgLm9uKCdjbGljaycsIChldmVudCwgZCkgPT4gdGhpcy5oYW5kbGVDbGljayhkLmlkKSk7CgogICAgfSwKICAgIGhhbmRsZUNsaWNrKGNvdW50cnlJZCkgewogICAgICBjb25zdCBpc1NlbGVjdGVkID0gdGhpcy5zZWxlY3RlZENvdW50cmllcy5pbmNsdWRlcyhjb3VudHJ5SWQpOwogICAgICBpZiAoIWlzU2VsZWN0ZWQpIHsKICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ2NoYW5nZVNlbGVjdGVkQ291bnRyaWVzJywgY291bnRyeUlkKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3JlbW92ZVNlbGVjdGVkQ291bnRyeScsIGNvdW50cnlJZCk7CiAgICAgIH0KICAgIH0sCiAgICBjaGVja1Zpc2liaWxpdHkoZCkgewogICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgdmlzaWJpbGl0eSBmb3I6JywgZCk7CiAgICAgIGNvbnN0IGlzV2l0aGluQm91bmRzID0gZC5sYW5kQ292ZXIgPD0gMTMwICYmIGQuY2FyYm9uU3RvY2tzIDw9IDIwMDsKICAgICAgcmV0dXJuIGlzV2l0aGluQm91bmRzID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7CiAgICB9LAoKICAgICAgCiAgICAvLyBjb2xvcmluZyB0aGUgZ3JpZAogICAgcGFpbnRDaGFydCh4U2NhbGUsIHlTY2FsZSkgewogICAgICB4U2NhbGUgPSB4U2NhbGUgfHwgdGhpcy54U2NhbGU7CiAgICAgIHlTY2FsZSA9IHlTY2FsZSB8fCB0aGlzLnlTY2FsZTsKICAgICAgY29uc3QgYmFja2dyb3VuZCA9IGQzLnNlbGVjdCh0aGlzLiRyZWZzLmdyaWRCYWNrZ3JvdW5kKTsKICAgICAgYmFja2dyb3VuZC5zZWxlY3RBbGwoJ3JlY3QnKS5yZW1vdmUoKQogICAgICBiYWNrZ3JvdW5kLnNlbGVjdEFsbCgnI3Bsb3QtYXJlYS1jbGlwLWJhY2tncm91bmQnKS5yZW1vdmUoKQogICAgICBjb25zdCBjb2xvcnMgPSBbCiAgICAgICAgInJnYigyMzAsIDIzMCwgMjMwKSIsCiAgICAgICAgInJnYigyMjAsIDE4MywgMjEwKSIsIC8vIDAgMSAKICAgICAgICAicmdiKDIxMSwgMTQ2LCAxOTQpIiwgLy8gMCAwIAogICAgICAgICJyZ2IoMTk1LCAyMzgsIDE5OSkiLCAvLyAxIDIgCiAgICAgICAgInJnYigxNTEsIDE4NSwgMTk5KSIsIAogICAgICAgICJyZ2IoMTY4LCAxNDAsIDE5MSkiLCAvLyAxIDAgCiAgICAgICAgInJnYigxNDgsIDIyMSwgMTY2KSIsIC8vIDIgMiAKICAgICAgICAicmdiKDEyOSwgMTg2LCAxNjIpIiwgLy8gMiAxIAogICAgICAgICJyZ2IoMTA3LCAxMjAsIDE1NSkiLAogICAgICBdOwogICAgICBiYWNrZ3JvdW5kLmFwcGVuZCgiZGVmcyIpLmFwcGVuZCgiY2xpcFBhdGgiKQogICAgICAgIC5hdHRyKCJpZCIsICJwbG90LWFyZWEtY2xpcC1iYWNrZ3JvdW5kIikKICAgICAgICAuYXBwZW5kKCJyZWN0IikKICAgICAgICAuYXR0cigid2lkdGgiLCB0aGlzLnN2Z1dpZHRoIC0gdGhpcy5zdmdQYWRkaW5nLmxlZnQgLSB0aGlzLnN2Z1BhZGRpbmcucmlnaHQpCiAgICAgICAgLmF0dHIoImhlaWdodCIsIHRoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20pOwogICAgICBjb25zdCB4Rmlyc3RUaWNrID0gdGhpcy5sYW5kQ292ZXJNaW4gKyAodGhpcy5sYW5kQ292ZXJNYXggLSB0aGlzLmxhbmRDb3Zlck1pbikvMzsKICAgICAgY29uc3QgeFNlY29uZFRpY2sgPSB0aGlzLmxhbmRDb3Zlck1pbiArIDIqKHRoaXMubGFuZENvdmVyTWF4IC0gdGhpcy5sYW5kQ292ZXJNaW4pLzM7CiAgICAgIGNvbnN0IHhWYWx1ZXMgPSBbdGhpcy5sYW5kQ292ZXJNaW4sIHhGaXJzdFRpY2ssIHhTZWNvbmRUaWNrLCB0aGlzLmxhbmRDb3Zlck1heF07CiAgICAgIGNvbnN0IHlGaXJzdFRpY2sgPSB0aGlzLmNhcmJvblN0b2Nrc01pbiArICh0aGlzLmNhcmJvblN0b2Nrc01heCAtIHRoaXMuY2FyYm9uU3RvY2tzTWluKS8zOwogICAgICBjb25zdCB5U2Vjb25kVGljayA9IHRoaXMuY2FyYm9uU3RvY2tzTWluICsgMioodGhpcy5jYXJib25TdG9ja3NNYXggLSB0aGlzLmNhcmJvblN0b2Nrc01pbikvMzsKICAgICAgY29uc3QgeVZhbHVlcyA9IFt0aGlzLmNhcmJvblN0b2Nrc01pbiwgeUZpcnN0VGljaywgeVNlY29uZFRpY2ssdGhpcy5jYXJib25TdG9ja3NNYXhdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHlWYWx1ZXMubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB4VmFsdWVzLmxlbmd0aCAtIDE7IGorKykgewogICAgICAgICAgYmFja2dyb3VuZC5hcHBlbmQoJ3JlY3QnKQogICAgICAgICAgICAuYXR0cigneCcsIHhTY2FsZSh4VmFsdWVzW2pdKSkKICAgICAgICAgICAgLmF0dHIoJ3knLCB5U2NhbGUoeVZhbHVlc1tpKzFdKSkKICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgKHhTY2FsZSh4VmFsdWVzW2orMV0pIC0geFNjYWxlKGopKSkKICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsICh5U2NhbGUoeVZhbHVlc1tpXSkgLSB5U2NhbGUoeVZhbHVlc1tpKzFdKSkpCiAgICAgICAgICAgIC5hdHRyKCJjbGlwLXBhdGgiLCAidXJsKCNwbG90LWFyZWEtY2xpcC1iYWNrZ3JvdW5kKSIpCiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3JzW2ogKyBpICogM10pCiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSk7CiAgICAgICAgICBiYWNrZ3JvdW5kLmFwcGVuZCgncmVjdCcpCiAgICAgICAgICAgIC5hdHRyKCd4JywgeFNjYWxlKHhWYWx1ZXNbal0pKQogICAgICAgICAgICAuYXR0cigneScsIHlTY2FsZSh5VmFsdWVzW2krMV0pKQogICAgICAgICAgICAuYXR0cignd2lkdGgnLCAwKSAgLy8gU3RhcnQgd2l0aCBhIHdpZHRoIG9mIDAgZm9yIHRoZSB0cmFuc2l0aW9uCiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAwKSAvLyBTdGFydCB3aXRoIGEgaGVpZ2h0IG9mIDAgZm9yIHRoZSB0cmFuc2l0aW9uCiAgICAgICAgICAgIC5hdHRyKCJjbGlwLXBhdGgiLCAidXJsKCNwbG90LWFyZWEtY2xpcC1iYWNrZ3JvdW5kKSIpCiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY29sb3JzW2ogKyBpICogM10pCiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMCkgLy8gU3RhcnQgd2l0aCBhbiBvcGFjaXR5IG9mIDAgZm9yIHRoZSB0cmFuc2l0aW9uCiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHhTY2FsZSh4VmFsdWVzW2orMV0pIC0geFNjYWxlKHhWYWx1ZXNbal0pKQogICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeVNjYWxlKHlWYWx1ZXNbaV0pIC0geVNjYWxlKHlWYWx1ZXNbaSsxXSkpCiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSk7CiAgICAgICAgfQogICAgICB9CiAgICB9LAogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGZpbHRlcmVkRGF0YSgpIHsKICAgICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLmZpbHRlcihkID0+IGQubGFuZENvdmVyICE9PSAwKTsKICAgIH0sCiAgICBjb21iaW5lZERhdGEoKSB7CiAgICAgIGxldCBjb21iaW5lZCA9IHRoaXMuY2FyYm9uU3RvY2tzLm1hcChjcyA9PiB7CiAgICAgICAgbGV0IGxhbmRDb3ZlckRhdGEgPSB0aGlzLmxhbmRDb3Zlci5maW5kKGxhbmRDb3ZlciA9PiBsYW5kQ292ZXIuaWQgPT09IGNzLmlkKTsKICAgICAgICBsZXQgZGlzYXN0ZXJzRnJlcURhdGEgPSB0aGlzLmRpc2FzdGVyc0ZyZXEuZmluZChkaXNhc3RlcnNGcmVxID0+IGRpc2FzdGVyc0ZyZXEuaWQgPT09IGNzLmlkKTsKICAgICAgICByZXR1cm4gewogICAgICAgICAgaWQ6IGNzLmlkLAogICAgICAgICAgY291bnRyeTogY3MuY291bnRyeSwKICAgICAgICAgIGNhcmJvblN0b2NrczogY3MudmFsdWUsCiAgICAgICAgICBsYW5kQ292ZXI6IGxhbmRDb3ZlckRhdGEgPyBsYW5kQ292ZXJEYXRhLnZhbHVlOiAwLAogICAgICAgICAgZGlzYXN0ZXJzRnJlcTogZGlzYXN0ZXJzRnJlcURhdGEgPyBkaXNhc3RlcnNGcmVxRGF0YS52YWx1ZTogLTEKICAgICAgICB9OwogICAgICB9KTsKICAgICAgcmV0dXJuIGNvbWJpbmVkOwogICAgfSwKICAgIGxhbmRDb3ZlcjogewogICAgICBnZXQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMubGFuZENvdmVyOwogICAgICB9CiAgICB9LAogICAgY2FyYm9uU3RvY2tzOiB7CiAgICAgIGdldCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5jYXJib25TdG9ja3M7CiAgICAgIH0KICAgIH0sCiAgICBkaXNhc3RlcnNGcmVxOiB7CiAgICAgIGdldCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kaXNhc3RlcnNGcmVxOwogICAgICB9CiAgICB9LAogICAgY2FyYm9uU3RvY2tzTWF4KCkgewogICAgICByZXR1cm4gMjAwOwogICAgfSwKICAgIGNhcmJvblN0b2Nrc01pbigpIHsKICAgICAgcmV0dXJuIDA7CiAgICB9LAogICAgbGFuZENvdmVyTWF4KCkgewogICAgICByZXR1cm4gMTMwOwogICAgfSwKICAgIGxhbmRDb3Zlck1pbigpIHsKICAgICAgcmV0dXJuIDcwOwogICAgfSwKICAgIHhTY2FsZSgpIHsKICAgICAgcmV0dXJuIGQzLnNjYWxlTGluZWFyKCkKICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5zdmdXaWR0aCAtIHRoaXMuc3ZnUGFkZGluZy5sZWZ0IC0gdGhpcy5zdmdQYWRkaW5nLnJpZ2h0XSkKICAgICAgICAuZG9tYWluKFt0aGlzLmxhbmRDb3Zlck1pbiwgdGhpcy5sYW5kQ292ZXJNYXhdKTsKICAgIH0sCiAgICB5U2NhbGUoKSB7CiAgICAgIHJldHVybiBkMy5zY2FsZUxpbmVhcigpCiAgICAgICAgLnJhbmdlUm91bmQoW3RoaXMuc3ZnSGVpZ2h0IC0gdGhpcy5zdmdQYWRkaW5nLnRvcCAtIHRoaXMuc3ZnUGFkZGluZy5ib3R0b20sIDBdKQogICAgICAgIC5kb21haW4oW3RoaXMuY2FyYm9uU3RvY2tzTWluLCB0aGlzLmNhcmJvblN0b2Nrc01heF0pOwogICAgfSwKICAgIAogICAgYnJ1c2hlZENvdW50cmllczogewogICAgICBnZXQoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMuYnJ1c2hlZENvdW50cmllczsKICAgICAgfQogICAgfSwKICAgIHNlbGVjdGVkQ291bnRyaWVzOiB7CiAgICAgIGdldCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5zZWxlY3RlZENvdW50cmllczsKICAgICAgfQogICAgfQogIH0sCiAgd2F0Y2g6IHsKICAgIGxhbmRDb3ZlcjogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIGxldCB4U2NhbGUgPSB0aGlzLnpvb21lZFhTY2FsZSB8fCB0aGlzLnhTY2FsZTsKICAgICAgICBsZXQgeVNjYWxlID0gdGhpcy56b29tZWRZU2NhbGUgfHwgdGhpcy55U2NhbGU7CiAgICAgICAgdGhpcy5kcmF3Q2hhcnQoeFNjYWxlLCB5U2NhbGUpOwogICAgICB9LAogICAgICBkZWVwOiB0cnVlLAogICAgfSwKICAgIGNhcmJvblN0b2NrczogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIGxldCB4U2NhbGUgPSB0aGlzLnpvb21lZFhTY2FsZSB8fCB0aGlzLnhTY2FsZTsKICAgICAgICBsZXQgeVNjYWxlID0gdGhpcy56b29tZWRZU2NhbGUgfHwgdGhpcy55U2NhbGU7CiAgICAgICAgdGhpcy5kcmF3Q2hhcnQoeFNjYWxlLCB5U2NhbGUpOwogICAgICB9LAogICAgICBkZWVwOiB0cnVlLAogICAgfSwKICAgIGRpc2FzdGVyc0ZyZXE6IHsKICAgICAgaGFuZGxlcigpIHsKICAgICAgICBsZXQgeFNjYWxlID0gdGhpcy56b29tZWRYU2NhbGUgfHwgdGhpcy54U2NhbGU7CiAgICAgICAgbGV0IHlTY2FsZSA9IHRoaXMuem9vbWVkWVNjYWxlIHx8IHRoaXMueVNjYWxlOwogICAgICAgIHRoaXMuZHJhd0NoYXJ0KHhTY2FsZSwgeVNjYWxlKTsKICAgICAgfSwKICAgICAgZGVlcDogdHJ1ZSwKICAgIH0sCiAgICBzZWxlY3RlZENvdW50cmllczogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIHRoaXMuZHJhd0NoYXJ0KHRoaXMuem9vbWVkWFNjYWxlLCB0aGlzLnpvb21lZFlTY2FsZSk7CiAgICAgIH0sCiAgICAgIGRlZXA6IHRydWUsCiAgICB9LAogICAgZmlsdGVyZWREYXRhOiB7CiAgICAgIGhhbmRsZXIoKSB7CiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7CiAgICAgIH0sCiAgICAgIGRlZXA6IHRydWUsCiAgICB9LAogICAgYnJ1c2hlZENvdW50cmllczogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIGlmICh0aGlzLnpvb21lZFhTY2FsZSAmJiB0aGlzLnpvb21lZFlTY2FsZSkgewogICAgICAgICAgdGhpcy5kcmF3UG9pbnRzKHRoaXMuem9vbWVkWFNjYWxlLCB0aGlzLnpvb21lZFlTY2FsZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuZHJhd1BvaW50cyh0aGlzLnhTY2FsZSwgdGhpcy55U2NhbGUpOwogICAgICAgIH0KICAgICAgfSwKICAgICAgZGVlcDogdHJ1ZSwKICAgIH0KICB9LAp9Cg=="},{"version":3,"sources":["Scatterplot_1.vue"],"names":[],"mappings":";;AAmBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Scatterplot_1.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"vis-component\" ref=\"chart\">\n    <h6>Carbon Stocks / Land Cover Information per Country</h6>\n    <svg id=\"scatter1-svg\" :width=\"svgWidth\" :height=\"svgHeight\" @dblclick=\"resetZoom\">\n      <g class=\"chart-group\" ref=\"chartGroup\">\n        <g class=\"grid-background\" ref=\"gridBackground\"></g>\n        <g class=\"brush-group\" ref=\"brushGroup\"></g>\n        <g class=\"axis axis-x\" ref=\"axisX\"></g>\n        <g class=\"axis axis-y\" ref=\"axisY\"></g>\n        <g class=\"points-group\" ref=\"pointsGroup\"></g>\n      </g>\n    </svg>\n    \n    <div id=\"tooltip\" class=\"tooltip\" style=\"opacity:0;\"></div>\n  </div>\n</template>\n\n<script>\n\nimport * as d3 from 'd3';\n\nexport default {\n  name: 'Scatterplot_1',\n  props: {\n  },\n  data() {\n    const svgWidth = window.innerWidth * 4 / 12;\n    const svgHeight = window.innerHeight * 0.35;\n    return {\n      zoomedXScale: null,\n      zoomedYScale: null,\n      svgWidth: svgWidth,\n      svgHeight: svgHeight,\n      svgPadding: {\n        top: 5, right: 15, bottom: 60, left: 60,\n      },\n    }\n  },\n  mounted() {\n    this.paintChart(this.xScale, this.yScale);\n    this.drawChart(this.xScale, this.yScale);\n    this.drawXAxis(this.xScale);\n    this.drawYAxis(this.yScale);\n    this.addBrush();\n    this.initialize();\n\n    d3.select('#scatter1-svg').on('click', (event) => {\n      if (event.target === d3.select('#scatter1-svg').node()) {\n        this.removeSelection();\n      }\n    });\n  },\n  methods: {\n    removeSelection() {\n      this.$store.commit('removeSelectedCountries');\n    },\n    initialize() {\n      var localbrushedCountries = [];\n      this.filteredData.forEach(d => localbrushedCountries.push(d.id));\n      this.$store.commit('changeBrushedCountries', localbrushedCountries);\n    },\n    resetZoom() {\n      this.zoomedXScale = null;\n      this.zoomedYScale = null;\n      this.paintChart(this.xScale, this.yScale);\n      this.drawChart(this.xScale, this.yScale);\n      this.initialize()\n    },\n    // called for each updage\n    drawChart(xScale, yScale) {\n      xScale = xScale || this.xScale;\n      yScale = yScale || this.yScale;\n\n      // Update axes\n      this.drawXAxis(xScale);\n      this.drawYAxis(yScale);\n      \n      d3.select(this.$refs.chartGroup)\n        .attr('transform', `translate(${this.svgPadding.left},${this.svgPadding.top})`);\n      this.drawPoints(xScale, yScale);\n    },\n    // brush for showing on choroplethmap\n    addBrush() {\n      this.brush = d3.brush()\n        .extent([[0,0], [this.svgWidth - this.svgPadding.left - this.svgPadding.right, \n          this.svgHeight - this.svgPadding.bottom - this.svgPadding.top]])\n        .on('end', this.onBrush);\n      \n      d3.select(this.$refs.brushGroup)\n        .attr('class', 'brush')\n        .call(this.brush);\n    },\n    // get states in brush\n    onBrush(event) {\n      const filteredPoints = this.filteredData.filter(d => this.brushedCountries.includes(d.id));\n      var selection = event.selection;\n      var localbrushedCountries = [];\n      \n      var x0,x1,y0,y1,idleTimeout;\n      if (!selection) {\n        filteredPoints.forEach(d => localbrushedCountries.push(d.id));\n        if (!idleTimeout) return idleTimeout = setTimeout(() => {\n          idleTimeout = null\n        }, 1);\n      } else {\n        // Calculate new scales for zoom\n        if (this.zoomedXScale) {\n          x0 = this.zoomedXScale.invert(selection[0][0]);\n          x1 = this.zoomedXScale.invert(selection[1][0]);\n          y0 = this.zoomedYScale.invert(selection[1][1]);\n          y1 = this.zoomedYScale.invert(selection[0][1]);\n        } else {\n          x0 = this.xScale.invert(selection[0][0]);\n          x1 = this.xScale.invert(selection[1][0]);\n          y0 = this.yScale.invert(selection[1][1]);\n          y1 = this.yScale.invert(selection[0][1]);\n        }\n\n        this.zoomedXScale = d3.scaleLinear().domain([x0, x1]).range([0, this.svgWidth - this.svgPadding.left - this.svgPadding.right]);\n        this.zoomedYScale = d3.scaleLinear().domain([y0, y1]).range([this.svgHeight - this.svgPadding.top - this.svgPadding.bottom, 0]);\n\n        // Redraw chart with new scales\n        this.drawChart(this.zoomedXScale, this.zoomedYScale);\n\n        // Filter brushed countries\n        filteredPoints.forEach(d => {\n          if (d.carbonStocks >= y0 && d.carbonStocks <= y1 && d.landCover >= x0 && d.landCover <= x1) {\n            localbrushedCountries.push(d.id);\n          }\n        });\n        \n      }\n\n      this.paintChart(this.zoomedXScale, this.zoomedYScale)\n\n      d3.select('#scatter1-svg').select(\".brush\").call(this.brush.move, null)\n\n      this.$store.commit('changeBrushedCountries', localbrushedCountries);\n    },\n    // X-axis\n    drawXAxis(xScale) {\n      const xAxisGroup = d3.select(this.$refs.axisX)\n        .attr('transform', `translate(0, ${this.svgHeight - this.svgPadding.top - this.svgPadding.bottom})`)\n        .call(d3.axisBottom(xScale))\n        .style('font-size', '10');\n\n      const xAxisText = xAxisGroup.selectAll('.x-axis-label').data(['Land Cover Index (Compared to 2015)']);\n\n      xAxisText.enter()\n        .append('text')\n        .attr('class', 'x-axis-label')\n        .merge(xAxisText)\n        .attr('x', this.svgWidth/2 + this.svgPadding.left + this.svgPadding.right + 5)\n        .attr('y', this.svgPadding.bottom - 10)\n        .attr('text-anchor', 'end')\n        .style('fill', 'black')\n        .style('font-size', '14px')\n        .text(d => d);\n      },\n    // Y-axis\n    drawYAxis(yScale) {\n      const yAxisGroup = d3.select(this.$refs.axisY)\n        .attr('transform', `translate( 0, 0)`)\n        .call(d3.axisLeft(yScale))\n        .style('font-size', '10');\n        \n      const yAxisText = yAxisGroup.selectAll('.y-axis-label').data(['Carbon Stocks']);\n\n      yAxisText.enter()\n        .append('text')\n        .attr('class', 'y-axis-label')\n        .merge(yAxisText)\n        .attr('transform', 'rotate(-90)')\n        .attr('y', -this.svgPadding.left + 5)\n        .attr('x', -this.svgHeight/4 + this.svgPadding.top + this.svgPadding.bottom + 10)\n        .attr('dy', '0.71em')\n        .attr('text-anchor', 'end') \n        .attr('fill', 'black')\n        .style('font-size', '14px')\n        .text(\"Carbon Stocks Index (Compared to 1992)\");\n    },\n    // add country points on scatterplot\n    drawPoints(xScale, yScale) {\n      const pointsGroup = d3.select(this.$refs.pointsGroup);\n      const filteredPoints = this.filteredData.filter(d => this.brushedCountries.includes(d.id));\n      console.log('filtered');\n      console.log(filteredPoints);\n\n      const tooltip = d3.select(\"#tooltip\");\n      const transition = d3.transition().duration(750);\n      filteredPoints.sort((a, b) => {\n        const aSelected = this.selectedCountries.includes(a.id);\n        const bSelected = this.selectedCountries.includes(b.id);\n        return aSelected === bSelected ? 0 : aSelected ? 1 : -1;\n      });\n      const xRange = xScale.range();\n      const yRange = yScale.range();\n      const inBoundData = filteredPoints.filter(d => {\n\n        const cx = xScale(d.landCover);\n        const cy = yScale(d.carbonStocks);\n        \n\n\n        return cx >= xRange[0] && cx <= xRange[1] && cy <= yRange[0] && cy >= yRange[1];\n      });\n\n      console.log('bounded');\n      console.log(inBoundData);\n\n\n      pointsGroup.selectAll('.point')\n        .data(inBoundData, function(d) { return d.id; })\n        .join(\n          enter => enter.append('circle')\n                        .attr('class', 'point')\n                        .attr('cx', d => xScale(d.landCover))\n                        .attr('cy', this.svgHeight - this.svgPadding.bottom) // start from bottom\n                        .attr('r', 6) // start from zero radius\n                        .call(enter => enter.transition(transition)\n                            .attr('cy', d => yScale(d.carbonStocks))\n                            .attr('r', 6)),\n          update => update.call(update => update.transition(transition)\n                            .attr('cx', d => xScale(d.landCover))\n                            .attr('cy', d => yScale(d.carbonStocks))),\n          exit => exit.call(exit => exit.transition(transition)\n                            .attr('cy', this.svgHeight - this.svgPadding.bottom)\n                            .attr('r', 6)\n                            .remove())\n        )\n        .attr('fill', d => this.selectedCountries.includes(d.id) ? \"rgb(253, 255, 181)\" : \"rgb(1, 39, 39)\")\n        \n        .on('mouseover', function(event, d) {\n          d3.select(this)\n            .raise()\n            .attr('stroke', 'aqua')\n            .attr('stroke-width', 2);\n          let landCoverTemp = d.landCover === 0 ? 'No Data' : d.landCover.toFixed(2);\n          let carbonStocksTemp = d.carbonStocks === 0 ? 'No Data' : d.carbonStocks.toFixed(2);\n          let disastersFreqTemp = d.disastersFreq === -1 ? 'No Data' : d.disastersFreq;\n          tooltip.transition()\n            .duration(200)\n            .style('opacity', 1);\n          tooltip.html(`\n            <table>\n              <tr><td class=\"label\">Country:</td>         <td class=\"country_value\">${d.country}</td></tr>\n              <tr><td class=\"label\">Carbon Stocks:</td>     <td class=\"value\">${carbonStocksTemp}</td></tr>\n              <tr><td class=\"label\">Land Cover:</td>        <td class=\"value\">${landCoverTemp}</td></tr>\n              <tr><td class=\"label\">Disasters Frequency:</td>     <td class=\"value\">${disastersFreqTemp}</td></tr>\n            </table>\n          `)\n          .style('left', (event.clientX - 275) + 'px')\n          .style('top', (event.clientY - 100) + 'px');\n        })\n        .on('mouseout', function() {\n          d3.select(this)\n            .attr('r', 6)\n            .attr('stroke', 'none')\n            .attr('stroke-width', 0);\n          tooltip.transition()\n            .duration(500)\n            .style('opacity', 0);\n        })\n        .on('click', (event, d) => this.handleClick(d.id));\n\n    },\n    handleClick(countryId) {\n      const isSelected = this.selectedCountries.includes(countryId);\n      if (!isSelected) {\n        this.$store.commit('changeSelectedCountries', countryId);\n      } else {\n        this.$store.commit('removeSelectedCountry', countryId);\n      }\n    },\n    checkVisibility(d) {\n      console.log('Checking visibility for:', d);\n      const isWithinBounds = d.landCover <= 130 && d.carbonStocks <= 200;\n      return isWithinBounds ? 'visible' : 'hidden';\n    },\n\n      \n    // coloring the grid\n    paintChart(xScale, yScale) {\n      xScale = xScale || this.xScale;\n      yScale = yScale || this.yScale;\n      const background = d3.select(this.$refs.gridBackground);\n      background.selectAll('rect').remove()\n      background.selectAll('#plot-area-clip-background').remove()\n      const colors = [\n        \"rgb(230, 230, 230)\",\n        \"rgb(220, 183, 210)\", // 0 1 \n        \"rgb(211, 146, 194)\", // 0 0 \n        \"rgb(195, 238, 199)\", // 1 2 \n        \"rgb(151, 185, 199)\", \n        \"rgb(168, 140, 191)\", // 1 0 \n        \"rgb(148, 221, 166)\", // 2 2 \n        \"rgb(129, 186, 162)\", // 2 1 \n        \"rgb(107, 120, 155)\",\n      ];\n      background.append(\"defs\").append(\"clipPath\")\n        .attr(\"id\", \"plot-area-clip-background\")\n        .append(\"rect\")\n        .attr(\"width\", this.svgWidth - this.svgPadding.left - this.svgPadding.right)\n        .attr(\"height\", this.svgHeight - this.svgPadding.top - this.svgPadding.bottom);\n      const xFirstTick = this.landCoverMin + (this.landCoverMax - this.landCoverMin)/3;\n      const xSecondTick = this.landCoverMin + 2*(this.landCoverMax - this.landCoverMin)/3;\n      const xValues = [this.landCoverMin, xFirstTick, xSecondTick, this.landCoverMax];\n      const yFirstTick = this.carbonStocksMin + (this.carbonStocksMax - this.carbonStocksMin)/3;\n      const ySecondTick = this.carbonStocksMin + 2*(this.carbonStocksMax - this.carbonStocksMin)/3;\n      const yValues = [this.carbonStocksMin, yFirstTick, ySecondTick,this.carbonStocksMax];\n      for (let i = 0; i < yValues.length - 1; i++) {\n        for (let j = 0; j < xValues.length - 1; j++) {\n          background.append('rect')\n            .attr('x', xScale(xValues[j]))\n            .attr('y', yScale(yValues[i+1]))\n            .attr('width', (xScale(xValues[j+1]) - xScale(j)))\n            .attr('height', (yScale(yValues[i]) - yScale(yValues[i+1])))\n            .attr(\"clip-path\", \"url(#plot-area-clip-background)\")\n            .attr('fill', colors[j + i * 3])\n            .attr('opacity', 1);\n          background.append('rect')\n            .attr('x', xScale(xValues[j]))\n            .attr('y', yScale(yValues[i+1]))\n            .attr('width', 0)  // Start with a width of 0 for the transition\n            .attr('height', 0) // Start with a height of 0 for the transition\n            .attr(\"clip-path\", \"url(#plot-area-clip-background)\")\n            .attr('fill', colors[j + i * 3])\n            .attr('opacity', 0) // Start with an opacity of 0 for the transition\n            .attr('width', xScale(xValues[j+1]) - xScale(xValues[j]))\n            .attr('height', yScale(yValues[i]) - yScale(yValues[i+1]))\n            .attr('opacity', 1);\n        }\n      }\n    },\n  },\n  computed: {\n    filteredData() {\n      return this.combinedData.filter(d => d.landCover !== 0);\n    },\n    combinedData() {\n      let combined = this.carbonStocks.map(cs => {\n        let landCoverData = this.landCover.find(landCover => landCover.id === cs.id);\n        let disastersFreqData = this.disastersFreq.find(disastersFreq => disastersFreq.id === cs.id);\n        return {\n          id: cs.id,\n          country: cs.country,\n          carbonStocks: cs.value,\n          landCover: landCoverData ? landCoverData.value: 0,\n          disastersFreq: disastersFreqData ? disastersFreqData.value: -1\n        };\n      });\n      return combined;\n    },\n    landCover: {\n      get() {\n        return this.$store.getters.landCover;\n      }\n    },\n    carbonStocks: {\n      get() {\n        return this.$store.getters.carbonStocks;\n      }\n    },\n    disastersFreq: {\n      get() {\n        return this.$store.getters.disastersFreq;\n      }\n    },\n    carbonStocksMax() {\n      return 200;\n    },\n    carbonStocksMin() {\n      return 0;\n    },\n    landCoverMax() {\n      return 130;\n    },\n    landCoverMin() {\n      return 70;\n    },\n    xScale() {\n      return d3.scaleLinear()\n        .rangeRound([0, this.svgWidth - this.svgPadding.left - this.svgPadding.right])\n        .domain([this.landCoverMin, this.landCoverMax]);\n    },\n    yScale() {\n      return d3.scaleLinear()\n        .rangeRound([this.svgHeight - this.svgPadding.top - this.svgPadding.bottom, 0])\n        .domain([this.carbonStocksMin, this.carbonStocksMax]);\n    },\n    \n    brushedCountries: {\n      get() {\n        return this.$store.getters.brushedCountries;\n      }\n    },\n    selectedCountries: {\n      get() {\n        return this.$store.getters.selectedCountries;\n      }\n    }\n  },\n  watch: {\n    landCover: {\n      handler() {\n        let xScale = this.zoomedXScale || this.xScale;\n        let yScale = this.zoomedYScale || this.yScale;\n        this.drawChart(xScale, yScale);\n      },\n      deep: true,\n    },\n    carbonStocks: {\n      handler() {\n        let xScale = this.zoomedXScale || this.xScale;\n        let yScale = this.zoomedYScale || this.yScale;\n        this.drawChart(xScale, yScale);\n      },\n      deep: true,\n    },\n    disastersFreq: {\n      handler() {\n        let xScale = this.zoomedXScale || this.xScale;\n        let yScale = this.zoomedYScale || this.yScale;\n        this.drawChart(xScale, yScale);\n      },\n      deep: true,\n    },\n    selectedCountries: {\n      handler() {\n        this.drawChart(this.zoomedXScale, this.zoomedYScale);\n      },\n      deep: true,\n    },\n    filteredData: {\n      handler() {\n        this.initialize();\n      },\n      deep: true,\n    },\n    brushedCountries: {\n      handler() {\n        if (this.zoomedXScale && this.zoomedYScale) {\n          this.drawPoints(this.zoomedXScale, this.zoomedYScale);\n        } else {\n          this.drawPoints(this.xScale, this.yScale);\n        }\n      },\n      deep: true,\n    }\n  },\n}\n</script>\n\n<style>\n</style>\n"]}]}